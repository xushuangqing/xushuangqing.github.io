<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xushuangqing.github.io</id>
    <title>卖萌凉</title>
    <updated>2021-07-10T09:39:04.739Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xushuangqing.github.io"/>
    <link rel="self" href="https://xushuangqing.github.io/atom.xml"/>
    <subtitle>&lt;p&gt;iOS开发者&lt;/p&gt;
&lt;p&gt;毕业于清华大学计算机系&lt;/p&gt;
&lt;p&gt;目前供职于字节跳动&lt;/p&gt;
&lt;p&gt;—&lt;/p&gt;
&lt;p&gt;如果你想了解我的生活，欢迎关注我的微信公众号：散步日历&lt;/p&gt;</subtitle>
    <logo>https://xushuangqing.github.io/images/avatar.png</logo>
    <icon>https://xushuangqing.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 卖萌凉</rights>
    <entry>
        <title type="html"><![CDATA[《SICP》读书笔记]]></title>
        <id>https://xushuangqing.github.io/post/《SICP》-du-shu-bi-ji/</id>
        <link href="https://xushuangqing.github.io/post/《SICP》-du-shu-bi-ji/">
        </link>
        <updated>2021-07-07T05:32:00.000Z</updated>
        <content type="html"><![CDATA[<p>因为图书角里恰好有这本书，我就借来看了。<br>
《计算机程序的构造和解释》是 MIT 的教材，国内的高校也有相关的课程。英文名叫做《Structure and Interpretation of Computer Programs》，简称 SICP，搜索 SICP 可以获得很多资料。这本书以 Scheme 语言为例，讲解了“程序是如何解释执行的”这个问题。针对这个问题，它在每一章引入了一系列越来越精确的模型，这个模型可以理解为程序执行的规则。从“代换模型”，扩充为“环境模型”，然后用 Scheme 本身实现了一个 eval 函数，称为“元循环解释器”，最后用寄存器机器实现了一个 Scheme 解释器。同时，这本书也引入和讨论了很多话题，比如抽象的层次、函数式编程等等。很多人说这本书能塑造计算机程序的三观，确实有挺多点让我对“程序”有了新的思考。<br>
<img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-12ceb9b1e8832e2e.png" alt="" loading="lazy"><br>
网上很多人称这本书为“时间黑洞”。emm 确实，我自己看书的程度只能算得上是走马观花，尤其是由于这本书的学习曲线是比较陡峭的（理论上它是设计给大一学生看的，emm），所以我对这五章内容的消化程度是指数级下降（emm）。所以此文只是讲一些我得到的收获。</p>
<p>这本书是以 Scheme 语言举例的。此处，为了让大家不用去理解 Scheme 语言的语法，我会借用 Swift 语法。但是这仅仅只是借用了 Swift 语法，而不考虑 Swift 的真实实现，可以假设有人给 Swift 做了另外一种实现，甚至有人写了一个 Swift 解释器。所以下面的 Swift 我都用了引号。</p>
<h3 id="一个简化的-swift">一个简化的 &quot;Swift&quot;</h3>
<p>首先，我们假设这个 &quot;Swift&quot; 只支持这几种语法：</p>
<ol>
<li>表达式</li>
</ol>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, an <strong>expression</strong> is a <a href="https://en.wikipedia.org/wiki/Syntax_(programming_languages)">syntactic</a> entity in a <a href="https://en.wikipedia.org/wiki/Programming_language">programming language</a> that may be evaluated to determine its value.</p>
</blockquote>
<pre><code>486

1 + 100

</code></pre>
<ol start="2">
<li>常量 -- let</li>
<li>过程定义 -- func / clousure</li>
<li>条件表达式 -- if</li>
</ol>
<p>这个 &quot;Swift&quot; 没有变量（var），没有循环（for/while），但是它已经可以做比直观想象中更多的事情了。</p>
<p>先从一个简单的例子开始：求 n 的阶乘：</p>
<pre><code>func factorial(_ n:Int) -&gt; Int {
  if n == 1 {
    return 1
  }
  return n * factorial(n-1)
}

factorial(6);
</code></pre>
<h3 id="代换模型">代换模型</h3>
<p>开头说过，这里举例的 &quot;Swift&quot; 代码，只是借用了 Swift 语法，可以认为是有人照着 Swift 语法实现了一个新的语言。所以当我们看着程序执行的时候，脑子里要抛弃掉内存、寄存器这样的概念。我们假设有一个机器，它能按照这样的规则执行 &quot;Swift&quot;：<br>
To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.<br>
对于组合式，先求值其中的子表达式<br>
找到要调用的过程的定义<br>
将过程体中的每个形参用相应的实参取代之后，对过程体求值</p>
<p>所以，factorial(6) 的计算过程会是</p>
<pre><code>factorial(6)
6*factorial(5)
6*(5*factorial(4))
6*(5*(4*factorial(3)))
6*(5*(4*(3*factorial(2))))
6*(5*(4*(3*(2*factorial(1)))))
6*(5*(4*(3*(2*1))))
6*(5*(4*(3*2)))
6*(5*(4*6))
6*(5*24)
6*120
720 
</code></pre>
<p>这种执行规则叫做“代换模型”。</p>
<h3 id="递归-vs-迭代">递归 vs 迭代</h3>
<p>我们很容易判断出，factorial 是一个递归过程。不管我们学习的是哪门语言，这个阶乘的实现都是讲“递归”时经典的例子。<br>
但是当我们写完一个算法题后，面试官看到这个阶乘的实现，很可能会继续问：“有没有迭代的实现方案？”<br>
如果我们用正常的 Swift 来回答这个问题，我们可以写</p>
<pre><code>func factorial(_ n: Int) -&gt; Int {
  var product = 1
  var count = 1
  while count &lt;= n {
    product = count * product
    count = count + 1
  }
  return product
}

factorial(6)
</code></pre>
<p>但是 &quot;Swift&quot; 是没有循环的，没有 for，没有 while。但是我们能从上面的实现中得到阶乘函数的重点：维持一个变动的乘积 product，以及一个 1~n 的计数器 counter，每一步都按照下面的规则变化：</p>
<pre><code>product ← counter * product
counter ← counter + 1 
</code></pre>
<p>因为 &quot;Swift&quot; 没有循环的，函数要达成循环的目的还是只能调用自己。所以在语法上，我们还是需要递归的形式（即自己调用自己），但是在计算过程中，我们可以仅用常数个状态变量来描述计算过程。所以我们这样重构了 factorial ：</p>
<pre><code>func fact_iter(_ product: Int, _ counter: Int, _ n: Int) -&gt; Int {
  if counter &gt; n {
    return product
  }
  else {
    return fact_iter((product * counter), (counter + 1), n)
  }
}

func factorial(_ n: Int) -&gt; Int {
  return fact_iter(1, 1, 6)
}
</code></pre>
<p>我们依然用代换模型去执行这段代码，它的计算过程会是：<br>
factorial(6)<br>
fact-iter(1, 1, 6)<br>
fact-iter(1, 2, 6)<br>
fact-iter(2, 3, 6)<br>
fact-iter(6, 4, 6)<br>
fact-iter(24, 5, 6)<br>
fact-iter(120, 6, 6)<br>
fact-iter(720, 7, 6)<br>
720</p>
<p>这里我们会发现，这两个版本的阶乘，计算过程的“形状”是不一样的。<br>
第一个版本中，总需要有存储空间去记忆“6*(5*(4*(3*(2*1))))”这样的信息，它的长度随着 n 线性增长。而在第二个版本中，虽然它在语法上仍然是递归的，但每一步需要的记忆的信息只有 product、counter 和 n。第二个版本的递归叫做尾递归。</p>
<p>因为第二个版本中，需要记忆的信息只有常数个，所以当这个语言引入了“循环”语法后，只要语言的实现者愿意，他就可以让循环和尾递归互为语法糖。比如 C 中，尾递归可以被编译器优化为循环。</p>
<h3 id="数据结构">数据结构</h3>
<p>这个简化版的 &quot;Swift&quot; 能计算 n 的阶乘，好像挺好想象的。现在我们再进一步，用这个 &quot;Swift&quot; 来实现几个数据结构，比如 List。</p>
<p>这里，我们要引入数据结构的一个基本单元：序对。<br>
<img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-8940bc6f7585d96c.png" alt="" loading="lazy"><br>
序对会把两个元素组合在一起。<br>
把多个序对组合，我们可以得到 List：<br>
<img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-5f140a3874c32c90.png" alt="" loading="lazy"><br>
以此类推，我们也可以通过序对的组合，得到二叉树等数据结构。</p>
<p>如果我们把序对当作数据结构的单位，它必要有三个函数：<br>
con、car、cdr<br>
con 负责把两个元素组合成一个序对。<br>
car 负责取出序对的第一个元素。<br>
cdr 负责取出序对的第二个元素。</p>
<p>那么我们如何用 &quot;Swift&quot; 实现一个序对呢？一种方式是这样的：</p>
<pre><code>func con(_ x: Any?, _ y: Any?) -&gt; (Int) -&gt; Any? {
  func dispatch(m: Int) -&gt; Any? {
    if m == 0 {
      return x
    }
    else {
      return y
    }
  }
  return dispatch;
}

func car(_ z: (Int) -&gt; Any?) -&gt; Any? {
  return z(0)
}

func cdr(_ z: (Int) -&gt; Any?) -&gt; Any? {
  return z(1)
}
</code></pre>
<p>我们把序对拼接称为 List，利用序对的这三个函数，我们可以构建 List，可以求 List 的长度，可以遍历一个 List，可以在遍历的同时作出操作。稍微复杂一点，使用这个基于代换模型的 &quot;Swift&quot; 和它构建的数据结构，我们可以写一些算法题了，比如书中有一道题是求解八皇后。</p>
<h3 id="函数式编程-vs-命令式编程">函数式编程 vs 命令式编程</h3>
<p>通过上面的几个程序，我们能明显感受到，这些程序的思维方式和我们以前学习的思维方式的不同。这源自于两种不同的“世界观”。</p>
<p>看起来，这个简化版的&quot;Swift&quot;，虽然连 var 也没有，但已经能做很多操作了。那有什么操作是这个 &quot;Swift&quot; 不能做的呢？</p>
<p>还是先从一个相对简单的例子看起：<br>
现在我们想要做一个累加器：</p>
<pre><code>func makeAccumulator(_ start: Int) {
...
}

let accumulator = makeAccumulator(100)
let q = accumulator(10) //110
let p = accumulator(10) //120
</code></pre>
<p>&quot;Swift&quot; 可以实现么？答案是不可以。<br>
在之前的几个样例程序中，如果我们用同样的参数对同一过程两次求值，会产生同样的结果。但是这个累加器不是的。它的执行隐含着“时间流逝”这个因素，第一次调用和第二次调用返回的结果是不一样的。</p>
<p>如果我们确定了要通过计算机里的时间顺序去模拟实际系统里时间的流逝，那么我们必须构造起一些计算对象，使他们的行为随着程序的运行而改变。<br>
如果我们希望模拟状态变量，那么语言里必须提供一个赋值运算符。</p>
<p>如果我们给 &quot;Swift&quot; 引入 var，那么 makeAccumulator 就可以实现了。</p>
<pre><code>func makeAccumulator(_ start: Int) -&gt; (Int) -&gt; Int {
  var total = start
  func accumulator(_ added: Int) -&gt; Int {
    total += added
    return total
  }
  return accumulator;
}

let accumulator = makeAccumulator(100)
let q = accumulator(10) //110
let p = accumulator(10) //120
</code></pre>
<p>只要我们不使用赋值，以同样的参数对同一过程的两次求值一定产生出同样的结果，因此就可以认为过程是在计算数学函数。不用任何赋值的程序设计称为“函数式程序设计”。<br>
与之相对应的，广泛采用赋值的程序设计被称为“命令式程序设计”</p>
<h3 id="环境模型">环境模型</h3>
<p>但在引入赋值之后，变量在程序运行的某些时刻代表一个值，在另一些时刻代表另外一个值。代换模型就不再有效了。<br>
这时，&quot;Swift&quot; 需要引入更复杂的“环境模型”。</p>
<p>环境是什么呢？环境是一系列 frame，每一个 frame 是一个映射表。这个映射表把名字和值映射起来。每个 frame 还包含一个指针，指向外围环境。如果某个 frame 是全局的，它就没有外围环境。一个变量相对于某个环境的值，是这个环境中，包含该变量的第一个 frame 里这个变量的约束值。<br>
<img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-0a1650a7b32da1b0.png" alt="" loading="lazy"><br>
比如这张图里，假设 x 是一个变量，在环境 B 里，x 的值是 3，在环境 A 里，x 的值是 7。</p>
<p>在环境模型里，一个过程是一个序对（Pair），由一些代码和一个指向环境的指针组成。过程只能通过 lambda 表达式创建。其中代码部分包含参数和过程体。</p>
<p>我们给 makeAccumulator 这段代码套上环境模型。</p>
<p>首先执行</p>
<pre><code>func makeAccumulator(_ start: Int) -&gt; (Int) -&gt; Int {
  var total = start
  func accumulator(_ added: Int) -&gt; Int {
    total += added
    return total
  }
  return accumulator;
}
</code></pre>
<p>（为了方便解释，这里先作弊一下，把 total 干掉，认为 start 是一个 var）</p>
<pre><code>let makeAccumulator = {(_ start: Int) -&gt; (Int) -&gt; Int in
  return { (_ added: Int) -&gt; Int in
    start += added
    return start
  }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-647b6b98dc2d6bcf.png" alt="" loading="lazy"></figure>
<p>我们按照过程的定义在环境模型中构造它。<br>
由于这个过程是在全局环境中被定义的，所以它的环境指针指向全局。同时，全局环境中 makeAccumulator 这个名字成为了这一过程的变量名，于是我们把 makeAccumulator 这个名字约束到这一过程上。</p>
<p>然后执行</p>
<pre><code>let accumulator = makeAccumulator(100)
</code></pre>
<p>这是一个过程调用。执行过程调用时有一个规则：<br>
在将一个过程应用于一组实际参数时，会建立起一个新环境，其中包含了将所有形式参数约束于对应的实际参数的框架，该框架的外围环境就是所用的那个过程的环境，随后就在这个新环境下求值过程体。<br>
这里我们首先建立了一个新环境，将形式参数 start 约束到实际参数 100。由于这个调用是在全局环境中发生的，所以新环境的外围环境是全局环境。</p>
<figure data-type="image" tabindex="2"><img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-c07a0a4a56d15c73.png" alt="" loading="lazy"></figure>
<p>从新环境中，我们能获取到 makeAccumulator 对应的过程体：</p>
<pre><code>{(_ start: Int) -&gt; (Int) -&gt; Int in
  return { (_ added: Int) -&gt; Int in
    start += added
    return start
  }
}
</code></pre>
<p>把 start 代入后，求值的到</p>
<pre><code>{ (_ added: Int) -&gt; Int in
    start += added
    return start
}
</code></pre>
<p>同时，全局环境中会增加 accumulate 到这一过程体的约束。</p>
<figure data-type="image" tabindex="3"><img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-c2d565ddca218e00.png" alt="" loading="lazy"></figure>
<p>接下来再执行<br>
let q = accumulator(10) //110</p>
<figure data-type="image" tabindex="4"><img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-51292594edf647d7.png" alt="" loading="lazy"></figure>
<p>这时，环境中的 start 从 100 变成了 110<br>
当下一行代码再次需要使用到 start 时，它取到的值就是 110。</p>
<p>有了环境模型以后，&quot;Swift&quot; 可以支持 var 的赋值运算。</p>
<h3 id="eval-apply">Eval &amp; apply</h3>
<p>回想刚刚，我们用环境模型执行了 accumulator 这个程序。我们会发现，在执行这个程序的过程中，我们用到了两个基本操作：</p>
<p>1、求值一个组合式时，先求值子表达式，然后将子表达式的结果代入，求出组合式的值（和代换模型一样）</p>
<p>2、当将参数应用到过程时，需要在一个新环境中求值这个过程体。为了构造这个新环境，我们需要用一个新的 frame 扩展当前的环境，在这个 frame 中，形式参数被约束到了实际参数（环境模型）</p>
<p>在将一个过程应用于一组实际参数时，会建立起一个新环境，其中包含了将所有形式参数约束于对应的实际参数的框架，该框架的外围环境就是所用的那个过程的环境，随后就在这个新环境下求值过程体。</p>
<p>这两个基本操作组成了一个循环，可以描述为 eval 和 apply 的循环。</p>
<figure data-type="image" tabindex="5"><img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-541309f5e7ea97cf" alt="" loading="lazy"></figure>
<p>Eval 的参数是一个表达式和一个环境，它返回这个表达式在环境中的求值结果。</p>
<p>Apply 的参数是一个过程和一个实际参数的表，他将实际参数应用于过程，相当于将过程转换成了表达式，返回出去，接着交给 Eval 处理。</p>
<p>这里我用伪代码来示意一下这个过程：</p>
<pre><code>func eval(exp, env) {
    if (is-self-evaluating(exp)) return exp
    elseif (is-variable(exp)) return lookup-variable-value(exp, env)
    elseif (is-definition(exp)) return eval-definition(exp, env)
    ...
    elseif (is-application(exp)) 
        return apply(eval(operator(exp), env)), list-of-values(operator(exp), env))
    else error...
}

</code></pre>
<p>刚才我们讲到了函数，这是对过程的抽象；讲到了序对，这是对数据的抽象。现在世界上有了另一种抽象，是对语言的抽象。</p>
<p>这本书一步一步实现了一个 Scheme 的元循环解释器。最后大概 300 多行代码，可以调试着玩玩。因为 Scheme 代码本身就是 Scheme 语言的一个“内置对象”，即列表，所以用 Scheme，可以轻易取出函数名，函数体，形参列表等等，简化了 eval 的实现。</p>
<h3 id="一个寄存器机器实现的解释器">一个寄存器机器实现的解释器</h3>
<p>刚才讲到的“代换模型”和“环境模型”都是理论上定义了一个规则。机器是怎么理解这个规则的呢？</p>
<p>还是用阶乘来举例</p>
<pre><code>func factorial(_ n: Int) -&gt; Int {
  func fact_iter(_ product: Int, _ counter: Int) -&gt; Int {
   if counter &gt; n {
    return product
   }
   else {
    return fact_iter((product * counter), (counter + 1))
   }
  }
  return fact_iter(1, 1)
}

factorial(6)
</code></pre>
<p>现在我们要来制造一个能计算阶乘的物理机器。<br>
这个机器由两部分组成：<br>
<img src="https://xushuangqing.github.io/post-images/%E3%80%8ASICP%E3%80%8B-du-shu-bi-ji/164542-7f4b295830778d9f.png" alt="" loading="lazy"></p>
<p>第一部分：</p>
<ul>
<li>每个方框表示一个寄存器</li>
<li>梯形表示一个计算器</li>
<li>带叉叉的圆圈表示一个开关，平时是断开的，如果有人按了一下，数据就像电流一样流了过去</li>
<li>圆圈表示一个检测，counter &gt; n 的时候会变成红色<br>
第二部分：<br>
我们告诉一个小朋友：如果检测圆圈没有变成红色，就按一下开关1，再按一下开关2。<br>
等开关变红色了，就从 product 的盒子里取出答案。</li>
</ul>
<p>这两个图可以描述简单的程序，但是描述大型机器就会很不方便。但其实上图描述中，我们只是用到了几个指令。我们可以创造一个语言，一条指令可以是其中几种东西之一：</p>
<ul>
<li>按一个开关，使得一个值被赋值给寄存器：assign</li>
<li>执行一个检测，亮一盏灯：test</li>
<li>根据灯的颜色，跳转到某条指令：branch</li>
<li>跳转到某条指令：goto<br>
这个机器便可以用指令来描述。</li>
</ul>
<h3 id="机器的抽象">机器的抽象</h3>
<p>上图中的 multi 元件，我们认为是现成的。但是如果世界上没有 multi 元件，而是需要用 add 元件构造，那可想而知，表示这个机器的图会更加复杂。<br>
这时我们可以想象，如果我们把 multi 单独做成一个机器，放在一边。每次需要使用 multi 的时候，把输入先存放到固定的寄存器中，执行 multi，然后把结果也存入固定的寄存器，再拷贝到需要它的地方，我们就可以实现 multi 机器的抽象。<br>
这时，指令集需要得到扩充。由于我们需要记录“结果需要被拷贝到哪”，我们需要扩充 assign 语句，使它能存放一个 label，也需要扩充 goto 语句，使它能从一个寄存器中读取 label，并跳转过去。</p>
<h3 id="栈">栈</h3>
<p>在第一个递归版本的阶乘函数中，我们已知，执行这个阶乘函数，需要记忆的信息与 n 成正比。<br>
由于寄存器只有常数个，为了执行递归的阶乘，我们需要引入新的数据存取的方式：栈。<br>
于是指令集再次得到扩充：save 表示将一个值入栈，restore 表示从栈中恢复一个值。</p>
<pre><code>func factorial(_ n:Int) -&gt; Int {
  if n == 1 {
    return 1
  }
  return n * factorial(n-1)
}

factorial(6);
</code></pre>
<p>【待续】</p>
<h3 id="参考资料">参考资料：</h3>
<p>SICP.pdf https://opendocs.github.io/sicp/sicp.pdf<br>
SICP solutions http://community.schemewiki.org/?SICP-Solutions<br>
如何准备 Scheme 环境 https://stackoverflow.com/questions/12322434/how-to-install-mit-scheme-on-mac/31601331#31601331<br>
https://lfkdsk.github.io/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么 iOS 14.5 下 fishhook 会 crash]]></title>
        <id>https://xushuangqing.github.io/post/wei-shen-me--iOS-14-5--xia--fishhook--hui--crash/</id>
        <link href="https://xushuangqing.github.io/post/wei-shen-me--iOS-14-5--xia--fishhook--hui--crash/">
        </link>
        <updated>2021-04-11T14:01:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="现象">现象</h2>
<p>将 fishhook <a href="https://github.com/facebook/fishhook/tree/8ef82f0711494ecc78d16bf6ce76f5ad92e5f67b">开源版本</a> 运行在 iOS 14.5 arm64e 的设备上，很容易可以复现一个 crash：</p>
<pre><code>static void (*orig_dispatch_async)(dispatch_queue_t queue, dispatch_block_t block);
static void hooked_dispatch_async(dispatch_queue_t queue, dispatch_block_t block) {
  orig_dispatch_async(queue, block);
}

- (void)startHook {
  struct rebinding r[] = {
    {&quot;dispatch_async&quot;, hooked_dispatch_async, (void *)&amp;orig_dispatch_async}
  };
  rebind_symbols(r, sizeof(r)/sizeof(struct rebinding));
}
</code></pre>
<p>Crash  会发生在</p>
<pre><code>indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;
</code></pre>
<p>这一行，crash 原因为 <code>EXC_BAD_ACCESS</code>。</p>
<p><img src="https://xushuangqing.github.io/post-images/wei-shen-me--iOS-14-5--xia--fishhook--hui--crash/164542-0c594faeaca37215.png" alt="" loading="lazy"><br>
也就是 <a href="https://github.com/facebook/fishhook/issues/82">#82</a> 反馈的问题。</p>
<h2 id="原因">原因</h2>
<p>在了解 <a href="https://www.jianshu.com/p/7d8922dadef3">fishhook 原理</a>后，经过一些调试分析，可以发现发生 crash 的原因：</p>
<p>被赋值的 <code>indirect_symbol_bindings[i]</code> 所在的内存区域，是只读的。而“赋值”是一个写操作，于是产生了 <code>EXC_BAD_ACCESS</code>。</p>
<p>Fishhook 考虑到过内存访问权限的问题，在 <a href="https://github.com/facebook/fishhook/pull/65/files">If hooking in __DATA_CONST, make writable before trying to write</a> 和 <a href="https://github.com/facebook/fishhook/pull/66/files">Properly restore protections for iOS 13</a> 这两个 PR 中，对于 <code>__DATA_CONST</code> 段中的数据，作者在</p>
<pre><code>indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;

</code></pre>
<p>这一行赋值操作之前，使用了 <code>mprotect</code> 将所属内存区域的访问权限改成了“读写”，在这一行赋值操作以后，再次使用 <code>mprotect</code> 将所属内存区域的访问权限改回了原始值。</p>
<p>然而这两个 PR 其实是有问题的：<br>
1、<code>mprotect</code> 修改内存区域的访问权限时，传入的内存地址是需要按页对齐的，所以开源版本的 fishhook 在旧版 iOS 系统上，<code>mprotect</code> 都有很大概率不成功（返回 -1），<a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/mprotect.2.html">官方文档</a>也印证了这点。</p>
<figure data-type="image" tabindex="1"><img src="https://xushuangqing.github.io/post-images/wei-shen-me--iOS-14-5--xia--fishhook--hui--crash/164542-ce2de2e917534672.png" alt="⬆️ iOS 14.4 测试结果" loading="lazy"></figure>
<p>2、<code>oldProtection = get_protection(rebindings);</code> 这一行的目的是保存原先的访问权限，但是传入的参数是错误的，这会导致“在这一行赋值操作以后，再次使用 <code>mprotect</code> 将所属内存区域的访问权限改回了原始值”在实际执行中，“改回了原始值”实际是“改成可读写”（当然由于 <code>mprotect</code> 页对齐的问题很大概率修改不成功），因为 rebindings 是 malloc 出来的。</p>
<p>所以，一直以来，这两个 PR 大概率没有发挥预期的作用， <code>indirect_symbol_bindings[i]</code> 所在的内存区域，如果在程序启动后是只读的，那么 fishhook 的过程中，它也是只读的。只要赋值，就会触发 crash。</p>
<h2 id="为什么-crash-只发生在-ios-145">为什么 crash 只发生在 iOS 14.5？</h2>
<p>在我构造的复现环境中，crash 发生在对系统库 libxpc.dylib 的 <code>__DATA_CONST</code> 段 <code>__auth_got</code> 节的重绑定中，此时 <code>indirect_symbol_bindings[i]</code> 位于 <code>__DATA_CONST</code> 段 <code>__auth_got</code> 节映射到内存的区域中。我们来对比一下 iOS 14.4 和 iOS 14.5 的区别：<br>
1、无论是 iOS 14.4 还是 iOS 14.5，<code>mprotect</code> 修改内存区域为读写时，都失败了（返回 -1）。<br>
2、但是在 <code>mprotect</code> 修改前，iOS 14.4 上 <code>indirect_symbol_bindings[i]</code> 所在的内存区域是读写的，而 iOS 14.5 上变成了只读。</p>
<p>为了便于理解，我们可以在程序启动后、fishhook 开始前，通过 memory graph 来观察各个内存区域的访问权限：</p>
<blockquote>
<p>抓取 memory graph 后，在 Xcode 中选择 File -&gt; Export Memory Graph，导出 memory graph 后使用 vmmap 命令得到各个内存区域的快照</p>
</blockquote>
<p>观察 libxpc.dylib 的 <code>__DATA_CONST</code> 段映射在内存中的访问权限：</p>
<pre><code># iOS 14.5 
__DATA_CONST                1edadef10-1edae35c0    [   18K    18K     4K     0K] r--/rw- SM=COW          /usr/lib/system/libxpc.dylib
# iOS 14.4
__DATA_CONST                1f30167b0-1f301ae70    [   18K    18K     6K     0K] rw-/rw- SM=COW          /usr/lib/system/libxpc.dylib
</code></pre>
<p>可以发现，iOS 14.5 中，libxpc.dylib 的 <code>__DATA_CONST</code> 段是只读的，而 iOS 14.4 中是读写的。<br>
同时观察其他系统库，能发现 iOS 14.5 中，不少系统库的 <code>__DATA_CONST</code> 段都从 iOS 14.4 的读写变成了只读，同时撞上了一直以来都有的 <code>mprotect</code> 失效的问题，所以产生了 crash。</p>
<p>@maniackk 在 github 上的 PR <a href="https://github.com/facebook/fishhook/pull/84">If hooking in __DATA_CONST/__AUTH_CONST, promise writable before trying to write #84</a> 中对上文所说的两个问题做了解决。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 14 -[UIInputResponderController prepareToMoveKeyboardForInputViewSet:animationStyle:] crash 解决]]></title>
        <id>https://xushuangqing.github.io/post/iOS-14---[UIInputResponderController-prepareToMoveKeyboardForInputView/</id>
        <link href="https://xushuangqing.github.io/post/iOS-14---[UIInputResponderController-prepareToMoveKeyboardForInputView/">
        </link>
        <updated>2020-07-12T12:47:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>7 月 8 日 iOS 14 beta 2 放出后，我们注意到一个 crash 激增了起来。</p>
<p>这个 crash 顶部的堆栈为：</p>
<pre><code>0        _objc_retain (in libobjc.A.dylib)
1        -[UIInputResponderController prepareToMoveKeyboardForInputViewSet:animationStyle:] (in UIKitCore)
2        -[UIInputResponderController setKeyWindowSceneInputViews:animationStyle:] (in UIKitCore)
3        -[UIInputResponderController setInputViews:animationStyle:] (in UIKitCore)
4        -[UIInputResponderController setInputViews:animated:] (in UIKitCore)
5        -[UIInputResponderController setInputViews:] (in UIKitCore)
......
</code></pre>
<p>并且我们注意到，这个问题的触发，和业务形态没有特别密切的联系，多个 app 都遇到了这个崩溃，且量级不低。</p>
<h1 id="修复方案">修复方案</h1>
<p>先抛出一下我们最后确定的修复方案：</p>
<p>hook 私有方法 <code>-[UIInputViewSet restorableResponder]</code>，直接返回 <code>nil</code>。</p>
<p>由于是系统库自身的问题，我们没有源码，很难保证这个修复没有引入新的坑。但从目前的测试结果来看，至少崩溃不再复现了，并且看起来有关联的键盘场景，也没有严重问题。</p>
<h1 id="原因定位">原因定位</h1>
<p>造成 crash 的原因，是系统私有类 <code>UIInputViewSet</code> 中的 <code>restorableResponder</code> 属性，既不是 weak 也不是 strong，类似于 unsafe_unretained。所以当它被访问时，很容易造成野指针。当它被赋值给一个 <code>__strong id</code> 类型的变量时，则会在 <code>_objc_retain</code> 中崩溃。</p>
<p>我们可以打符号断点，从汇编中确认， iOS 14 beta 2 中，restorableResponder 属性的 getter 和 setter 方法，只是存取了一个内存值，没有做任何 weak 或 strong 应有的操作。</p>
<p><img src="https://xushuangqing.github.io/post-images/iOS-14---%5BUIInputResponderController-prepareToMoveKeyboardForInputView/164542-fccf065a692031aa.png" alt="" loading="lazy"><br>
<img src="https://xushuangqing.github.io/post-images/iOS-14---%5BUIInputResponderController-prepareToMoveKeyboardForInputView/164542-e8ce966189f633a9.png" alt="" loading="lazy"><br>
（从汇编指令看，没有 storeWeak 或 storeStrong 操作）</p>
<p>可以 hook  <code>-[UIInputViewSet restorableResponder]</code> 方法，验证一下它的返回值是不是经常是个野指针。</p>
<h1 id="定位过程">定位过程</h1>
<p>是怎么定位到 <code>-[UIInputViewSet restorableResponder]</code> 方法的呢？我的思路是这样的：</p>
<p>1、猜测问题来源于最顶栈  <code>-[UIInputResponderController prepareToMoveKeyboardForInputViewSet:animationStyle:] (in UIKitCore)</code> 的参数</p>
<p>2、hook <code>-[UIInputResponderController prepareToMoveKeyboardForInputViewSet:animationStyle:]</code> 方法，获取传入的参数，发现有两个参数，第一个参数类型是 UIInputViewSet，这两个参数本身不是野指针。</p>
<p>3、hook <code>-[UIInputResponderController prepareToMoveKeyboardForInputViewSet:animationStyle:]</code>，尝试将传入的两个参数改成 nil，发现 crash 不复现了。这基本可以确认问题出在参数上。但参数本身不是野指针，所以推测问题出现在参数某个方法的返回值上。</p>
<p>4、根据一份旧的 <a href="https://developer.limneos.net/?ios=11.0&amp;framework=UIKit.framework&amp;header=UIInputViewSet.h">UIInputViewSet 头文件</a>，在 lldb 中依次对这个 UIInputViewSet 对象发送消息。发现其中有个属性 restorableResponder，在旧版本上标记为 weak，但 getter 方法 return 出来的地址不是一个对象。严重怀疑这是一个野指针。</p>
<p>5、hook <code>-[UIInputViewSet restorableResponder]</code>，返回 nil，crash 不复现，确认问题出在 <code>-[UIInputViewSet restorableResponder]</code> 方法上</p>
<p>6、通过汇编确认 <code>restorableResponder</code> 在 iOS 14 beta 2 上既不是 strong 也不是 weak</p>
<p>相信很多团队都遇到了这个 crash，先前在网络上搜索未果，暂且抛出我的解决方案，欢迎与大家交流。<br>
当然最终还是等苹果爸爸真正修复它 😭</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从 Exported Symbols 应用于包大小优化说到符号绑定]]></title>
        <id>https://xushuangqing.github.io/post/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/</id>
        <link href="https://xushuangqing.github.io/post/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/">
        </link>
        <updated>2020-06-15T04:44:29.000Z</updated>
        <content type="html"><![CDATA[<p>之前写过 <a href="https://www.jianshu.com/p/11710e7ab661">Xcode中和symbols有关的几个设置</a>，天真地以为只要把和 <code>STRIP_INSTALLED_PRODUCT</code> 打开，且选择 <code>STRIP_STYLE</code> 为 All Symbols 就能让包大小在“符号”层面达到最优。毕竟剥离掉的是“All Symbols”啊。</p>
<p>直到经人指点发现了 <code>EXPORTED_SYMBOLS_FILE</code> 这个配置，才发现 Strip 能控制的并非全部符号。合理配置 Exported Symbols，可以进一步在“符号”层面优化二进制文件的大小。</p>
<p>为了便于解释，我们首先来介绍下动态库的<code>EXPORTED_SYMBOLS_FILE</code>配置，再发散到可执行文件上。</p>
<h2 id="exported_symbols_file-配置项是什么">EXPORTED_SYMBOLS_FILE 配置项是什么？</h2>
<p><code>EXPORTED_SYMBOLS_FILE</code> 是 Xcode Build Settings 中的一个配置项。默认为空。</p>
<figure data-type="image" tabindex="1"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-714c6932db29e791.png" alt="" loading="lazy"></figure>
<p>Xcode 的文档中，我们可以读到官方对这个配置项的解释：</p>
<blockquote>
<p>EXPORTED_SYMBOLS_FILE<br>
This is a project-relative path to a file that lists the symbols to export. See <code>ld -exported_symbols_list</code> for details on exporting symbols.</p>
</blockquote>
<p>需要在 <code>EXPORTED_SYMBOLS_FILE</code> 填入的是一个文件路径，这个文件以白名单的形式列出了需要被 export 的所有符号。未被列入的符号将不被 export。</p>
<p>接着去看 man ld 中对 <code>-exported_symbols_list</code> 的解释：</p>
<blockquote>
<p><strong>-exported_symbols_list</strong> filename<br>
The specified filename contains a list of global symbol names that will remain as global symbols in the output file.  All other global symbols will be treated as if they were marked as <code>__private_extern__</code> (aka visibility=hidden) and will not be global in the output file. The symbol names listed in filename must be one per line.  Leading and trailing white space are not part of the symbol name.  Lines starting with # are ignored, as are lines with only white space.  Some wildcards (similar to shell file matching) are supported.  The * matches zero or more characters.  The ? matches one character.  [abc] matches one character which must be an 'a', 'b', or 'c'.  [a-z] matches any single lower case letter from 'a' to 'z'.</p>
</blockquote>
<p>也就是说，如果设置了 <code>EXPORTED_SYMBOLS_FILE</code> 配置项，那么不在  <code>EXPORTED_SYMBOLS_FILE</code> 中的符号，就会被认为是 <code>__private_extern__</code> 的。</p>
<h2 id="被导出的符号存在哪里">被导出的符号存在哪里？</h2>
<p><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-90aa744a0c511bd1.png" alt="" loading="lazy"><br>
通过对比可以发现，被导出的符号存在动态库的 Export Info 中。</p>
<h2 id="这些符号是怎么被用到的">这些符号是怎么被用到的？</h2>
<p>动态库的“符号”是怎么被用到的？</p>
<p>可以想象，如果可执行文件 A 想要调用动态库中的一个函数 B，A 在静态的编译链接完成后，并不知道 B 函数在内存中的地址。B 函数的地址也是运行时计算得到的。这个过程叫做“绑定”。</p>
<p>Export Info 中的信息就是必不可少的一环。</p>
<h2 id="走一遍动态库函数调用流程">走一遍动态库函数调用流程</h2>
<p>那么现在我们就来走一遍动态库中函数调用的流程。</p>
<p>可执行文件 XSQExportIOSDemo 将调用动态库 XSQFramework 中的方法 _helloFramework。</p>
<figure data-type="image" tabindex="2"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-f3b8993fc4908db2.png" alt="" loading="lazy"></figure>
<h3 id="1-__text-__text-️-__text-__stubs">1、__TEXT, __text ➡️ __TEXT, __stubs</h3>
<p>可以在 XSQExportIOSDemo 形成可执行文件后的 __TEXT, __text 段中，找到 helloFramework() 这行调用对应的汇编。</p>
<figure data-type="image" tabindex="3"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-89589f550a641b39.png" alt="" loading="lazy"></figure>
<p>bl 指令会使程序跳到 0x100006568 的地址中执行，这个地址位于 __TEXT, __stubs 节。</p>
<h3 id="2-__text-__stubs-️-__data-__la_symbol_ptr">2、__TEXT, __stubs ➡️ __DATA, __la_symbol_ptr</h3>
<p>查看 0x100006568 地址中的内容，<br>
<img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-0f8075545559c6e3.png" alt="" loading="lazy"></p>
<p>nop 为空命令</p>
<p>ldr 这一行的意思是，将当前 pc 寄存器中的值，加上 0x1aac，再存到 x16 寄存器中</p>
<p>br 这一行的意思是，跳转到 x16 寄存器的值指向的地址。</p>
<p>x16 中存储的数，将会是 0x10000656c + 0x1aac = 0x100008018。0x100008018 位于 __DATA, __la_symbol_ptr 节。</p>
<h3 id="3-__data-__la_symbol_ptr-️-__text-__stub_helper">3、__DATA, __la_symbol_ptr ➡️ __TEXT, __stub_helper</h3>
<p>__la_symbol_ptr 节是一系列指针，这些指针指向的，是某一个指令的地址。<br>
<img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-23ab44e52d97d65a.png" alt="" loading="lazy"></p>
<p>0x100008018 对应的 0x100006604，位于 __TEXT, __stub_helper 节。<br>
<img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-51bf6e526c7ee396.png" alt="" loading="lazy"></p>
<h3 id="4-__text-__stub_helper-️-dyld_stub_binder">4、__TEXT, __stub_helper ➡️ dyld_stub_binder</h3>
<p>接下来，指令会随着 b 0x1000065ec 指令，跳转到 0x1000065ec，这个地址是 __stub_helper 节的开头。</p>
<p>如果用 Hopper 查看，会发现指令经过一些准备工作，最终会跳转到 dyld_stub_binder 函数。<br>
<img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-b54f9dfe6df7a9a4.png" alt="" loading="lazy"></p>
<p>dyld_stub_binder 就是用于动态绑定的函数。刚才的路途中，我们看到了 __la_symbol_ptr 节。__la_symbol_ptr 映射到内存后，是一个函数指针的数组。符号绑定的最终目的，是将 helloFramework() 真正在内存中的地址，写入到这个数组中。这样下次 helloFramework() 函数被调用，就不再走绑定流程，指令将直接进入到 helloFramework() 真正在内存中的地址中。</p>
<p>那接下来有两个关键点：</p>
<ol>
<li>需要找到被写入的地址，也就是 __la_symbol_ptr 节中哪个位置是需要被覆盖的。</li>
<li>需要找到 helloFramework() 真正在内存中的地址</li>
</ol>
<p>接下来的步骤，我们将结合 dyld 源码和符号断点调试来推演。</p>
<p>dyld 是开源的，我们可以下载源码了解其中的部分逻辑：<a href="https://opensource.apple.com/tarballs/dyld/">源码</a></p>
<p>如果我们想验证某个函数是否被执行了，Xcode 的符号断点可以利用起来。但这里有个小技巧：dyld 本身的函数由于执行太过频繁，lldb 默认不会将符号断点断在 dyld 的函数上。需要在 ~/.lldbinit 文件中加上</p>
<pre><code>set set target.breakpoints-use-platform-avoid-list 0
</code></pre>
<p>这一行，才能用符号断点来调试 dyld。我们可以通过符号断点的断住时的调用栈信息，窥探符号绑定的过程中做了什么。</p>
<h3 id="5-进入-dyld_stub_binder获取参数">5、进入 dyld_stub_binder，获取参数</h3>
<p>进入 dyld_stub_binder 之前，有一些准备工作可以分析一下。</p>
<p>dyld_stub_binder 函数是用汇编写的。从注释中可以推测，它接收两个参数：</p>
<pre><code> /*    
  * sp+0        lazy binding info offset
  * sp+8        address of ImageLoader cache
  */
</code></pre>
<p>而在 __TEXT, __stub_helper 节中，调用 dyld_stub_binder 之前，有一个压栈操作：<br>
<img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-6bb0cfcaa2c3ec52.png" alt="" loading="lazy"></p>
<pre><code>00000001000065f4        stp        x16, x17, [sp, #-0x10]!
</code></pre>
<p>x16 就是 dyld_stub_binder 的参数，代表 lazy binding info offset。</p>
<p>x16 的值是怎么来的呢？我们再倒退一步，刚才在跳转到 __TEXT, __stub_helper 的第一行之前，有一个准备工作：</p>
<figure data-type="image" tabindex="4"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-9e6d45d7ef7381e6.png" alt="" loading="lazy"></figure>
<pre><code>0000000100006604        ldr        w16, 0x10000660c
</code></pre>
<p>Ldr 这行指令的意思是，将 0x10000660c 这个地址里的值，加载到 w16 寄存器中。w16 寄存器和 x16 寄存器其实是同一个，只是使用 w16 访问时，它是一个 32 位的数。</p>
<p>那么  0x10000660c 这个地址里的值是什么？它位于 __TEXT, __stub_helper 节，值为 0x32。（其实就是下一行）<br>
<img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-653b4b296caa4172.png" alt="" loading="lazy"></p>
<p>这个 0x32 是一个重要的参数，接下来和绑定有关的信息将从这个 0x32 中衍生出来。</p>
<h3 id="6-读取-lazy-binding-info">6、读取 lazy binding info</h3>
<p>dyld_stub_binder 函数是汇编写的，它调用了 dyld::fastBindLazySymbol(ImageLoader** imageLoaderCache, uintptr_t lazyBindingInfoOffset) 函数。</p>
<p>然后按照这个调用栈，<br>
<img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-ce640b5a5b63fc5a.png" alt="" loading="lazy"></p>
<p>调用到了</p>
<pre><code>ImageLoaderMachOCompressed::doBindFastLazySymbol(uint32_t lazyBindingInfoOffset, const LinkContext&amp; context,
                                                                                                                        void (*lock)(), void (*unlock)())
</code></pre>
<p>函数。</p>
<p>doBindFastLazySymbol 函数将读取 MachO 文件的 lazy binding info 信息。</p>
<figure data-type="image" tabindex="5"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-3cc53b52f8a8be7b.png" alt="" loading="lazy"></figure>
<p>lazy binding info 信息在 MachO 靠近尾部的部分。</p>
<p>这时，0x32 这个 lazyBindingInfoOffset 这个数就要派上用场。</p>
<p>Lazy binding info 从 0x10000C2A0 开始。加上 0x32 这个 offset 后，dyld 将会去读取 0x10000C2D2 的内容。</p>
<figure data-type="image" tabindex="6"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-dab5cc5bc6a2f7fb.png" alt="" loading="lazy"></figure>
<p>MachOView 已经帮我们将这段数字翻译了一下。从中 dyld 可以读取到的信息有：<br>
segment(2)、offset(24)、dylib(1)、flags(0)、name(_helloFramework)<br>
最后的 BIND_OPCODE_DONE 代表的意思是，读到这一行后，dyld 将不再继续往下读。所以对于 helloFramework() 这次函数调用，这次绑定只会绑定 _helloFramework 一个符号。</p>
<p>segment(2)、offset(24) 组合，可以得到“需要被替换的地址”。<br>
dylib(1)，可以得到，dyld 应该从哪个动态库里去查找 _helloFramework 这个符号。<br>
name(_helloFramework)，可以得到符号的名字。</p>
<h3 id="7-找到-__data-__la_symbol_ptr-中需要被替换的地址">7、找到 __DATA, __la_symbol_ptr 中，“需要被替换的地址”</h3>
<p>segment(2)、offset(24) 组合，可以得到“需要被替换的地址”。关键代码为</p>
<pre><code>ImageLoaderMachOCompressed::doBindFastLazySymbol
</code></pre>
<p>中的</p>
<pre><code>uintptr_t address = segActualLoadAddress(segIndex) + segOffset;
</code></pre>
<p>这一行</p>
<p>从 segment(2) 这个信息中，dyld 会去寻找第 index=2 个 Load Command,也就是 LC_SEGMENT_64(__DATA），<br>
<img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-057080ac2b4885af.png" alt="" loading="lazy"></p>
<p>通过 VM Address 找到内存中的 __DATA 段的起始地址（4295000064 转换为 16 进制为 0x100008000）。</p>
<p>0x100008000 再加上 offset=24，就是“需要被替换的地址”。即 0x100008000 + 0x18 = 0x100008018。这个地址位于 __la_symbol_ptr 节，正好回到了 helloFramework() 刚才走到过的 __la_symbol_ptr 节的位置。</p>
<figure data-type="image" tabindex="7"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-8cd8429d8eb7f94b.png" alt="" loading="lazy"></figure>
<h3 id="8-确定去哪个动态库找-_helloframework">8、确定去哪个动态库找 _helloFramework</h3>
<p>从刚才从 lazy binding info 中读取到的 dylib(1)，可以得到，dyld 应该从哪个动态库里去查找 _helloFramework 这个符号。</p>
<p>关键的代码是</p>
<pre><code>ImageLoaderMachOCompressed::resolve
</code></pre>
<p>中的</p>
<pre><code>*targetImage = libImage((unsigned int)libraryOrdinal-1);
</code></pre>
<p>ImageLoader::recursiveLoadLibraries 的时候，会按照 LC_LOAD_DYLIB 的顺序 setLibImage。现在 getLibImage 能得知每个动态库的加载地址。</p>
<figure data-type="image" tabindex="8"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-1f6cf366c32237ff.png" alt="" loading="lazy"></figure>
<h3 id="9-寻找-_helloframework-真正对应的地址">9、寻找 _helloFramework 真正对应的地址</h3>
<p>现在我们需要搬出 XSQIOSFrameworkDemo 的 MachO 文件，这是一个动态库的 MachO 文件。<br>
在最开头介绍 Exported Symbols 的时候，我们已经知道，Exported Symbols 的信息，是记录在动态库的 MachO 的 Export Info 中的。<br>
<img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-ced0714bbc2c2262.png" alt="" loading="lazy"></p>
<p>Export Info 的信息，使用了 trie 树（前缀树）这种数据结构做了编码。我们在 dyld 的源码中找到了和 trie 树解析相关的函数：trieWalk。给这个函数增加符号断点，我们得到了 dyld 通往 trie 树解析的调用栈。</p>
<figure data-type="image" tabindex="9"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-e45e22fc1080575d.png" alt="" loading="lazy"></figure>
<p>从 resolveTwolevel 这个函数开始，这个过程最终的目的，就是从 XSQIOSFrameworkDemo 的 Image 中，找到 _helloFramework 真正的地址。</p>
<p>其中 Export Info 中可以提供的信息是：_helloFramework 符号对应的<br>
Flags 00<br>
Symbol Offset 0x7EB4</p>
<p>0x7EB4 这个 Offset 从 MachO 角度，确实是 _helloFramework 符号对应的指令的起始。</p>
<figure data-type="image" tabindex="10"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-716306455ce1d890.png" alt="" loading="lazy"></figure>
<h3 id="10-将-_helloframework-真正的地址写入-__la_symbol_ptr-中">10、将 _helloFramework 真正的地址写入 __la_symbol_ptr 中</h3>
<p>ImageLoaderMachO::bindLocation 函数将会通过 *locationToFix = newValue; 这一行，将 _helloFramework 的真正地址，写入 __la_symbol_ptr 对应的函数指针数组里。</p>
<p>至此，绑定的过程完成。如果下次继续调用 _helloFramework，则走到 2 这一步就可以直接进入 _helloFramework 的指令中。</p>
<h2 id="不导出符号有什么风险">不导出符号有什么风险？</h2>
<p>如果我们修改了 XSQIOSFrameworkDemo 的 EXPORTED_SYMBOLS_FILE，让它不导出符号，那么 Export Info 将空。绑定时，dyld 会报错，表现为 crash，因为它找不到 _helloFramework 的符号。</p>
<figure data-type="image" tabindex="11"><img src="https://xushuangqing.github.io/post-images/cong--Exported-Symbols--ying-yong-yu-bao-da-xiao-you-hua-shuo-dao-fu-hao-bang-ding/164542-d0155ee7dcaf6e9e.png" alt="" loading="lazy"></figure>
<p>但是，一个动态库中，并不是所有符号都需要被其他动态库使用的。私有的符号完全不需要在 Export Info 中体现。但大家写代码时，一般也考虑不到这些，并不会对函数、全局变量等加上 <code>__private_extern__</code>。</p>
<p><code>EXPORTED_SYMBOLS_FILE</code> 这个选项，可以在动态库打包，以白名单的形式指定需要暴露的符号。起到优化包大小、安全的作用。</p>
<h2 id="说回可执行文件">说回可执行文件</h2>
<p>试想，如果动态库想要反过来调用可执行文件的符号，会怎么样呢？<br>
可以想像，绑定的流程会和刚才类似，可执行文件的 Export Info 也会被读取。</p>
<p>之前我们给主工程使用 EXPORTED_SYMBOLS_FILE 优化了 2MB 包大小，优化前，主工程的 Export Info 包含了各种全局变量、OC 类的符号信息。在判断这个操作是否有风险时，通过对 Export Info 作用的分析，我们可以知道，这在我们的 app 中基本是没有风险的，除非有动态库想调用可执行文件的符号。</p>
<p>“有动态库想调用可执行文件的符号”，其实也有这个场景，就是自动化测试。所以现在，内测版保留了 Export Info 中的信息，正式版是不导出的。</p>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://opensource.apple.com/tarballs/dyld/">dyld 源码</a><br>
<a href="https://stackoverflow.com/questions/60764951/setting-breakpoint-in-dynamic-loader-on-ios-simulator">Setting breakpoint in dynamic loader on iOS simulator</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[UIImage imageNamed] 缓存策略窥探]]></title>
        <id>https://xushuangqing.github.io/post/[UIImage-imageNamed-]--huan-cun-ce-lve-kui-tan/</id>
        <link href="https://xushuangqing.github.io/post/[UIImage-imageNamed-]--huan-cun-ce-lve-kui-tan/">
        </link>
        <updated>2020-03-30T15:47:40.000Z</updated>
        <content type="html"><![CDATA[<p>都知道 [UIImage imageNamed:] 有一个缓存，但是试想，如果我们要对沙盒里的图片也做一个缓存，这个缓存应该怎么设计，似乎不是那么容易解答的问题。这么一想，[UIImage imageNamed:] 到底是如何设计这个缓存的，倒是一个可以探究的问题。</p>
<p>在探究之前，先试想一下，如果是我来设计 [UIImage imageNamed:] 的缓存，需要考虑哪些点？<br>
我能想到的有这样几点：</p>
<ol>
<li>[UIImage imageNamed:] 大部分情况下都是在主线程调用的，那么高效的磁盘 IO 很关键，并且需要尽可能减少 IO 的次数，防止卡顿；</li>
<li>图片最终显示前需要解码成 Bitmap，缓存图片压缩后的 Data 更好，还是缓存解码后的 Bitmap 更好，还是都缓存下来？显然 Bitmap 比对应的 Data 大几倍，如果选择缓存 Bitmap，那么可以缓存的图就更少，可能导致触发更多 IO；而如果选择缓存 Data，那么解码的开销便会增大。</li>
<li>图片缓存应该在什么场景下清理？memory warning 时显然需要清理，那退后台需要清理么？需要设置缓存的最大值么？</li>
</ol>
<p>基于这些想法，在窥探 [UIImage imageNamed:] 真正的缓存策略时，我也带上了这样几个问题：</p>
<ol>
<li>图片解码发生的时机是什么？</li>
<li>磁盘 IO 发生的时机是什么？</li>
<li>缓存的内容是什么？</li>
<li>清理缓存时机是什么？</li>
</ol>
<p>这篇文章就是对这几个问题的探索。</p>
<h2 id="问题一图片解码发生的时机是什么">问题一：图片解码发生的时机是什么？</h2>
<p>一句话回答：在 UIImage 显示到屏幕上时。</p>
<p><a href="https://dreampiggy.com/2019/01/18/%E4%B8%BB%E6%B5%81%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E9%A2%84%E8%A7%A3%E7%A0%81%E7%A9%B6%E7%AB%9F%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/#more">同事的博客</a>里对解码的时机有比较详细的介绍。总结下来就是，除了 Force Decode，只有当 UIImage 显示在屏幕上时，解码操作才会被触发。</p>
<p>通过设计一些实验，观察 app 内存水位的变化，也能快速验证这个结论。</p>
<p>但是，能预想到，后续的很多分析会和这个解码时机有较强的关联。如果能知道到底那个函数代表了解码操作，那后续的验证也会有力很多。<br>
这里我能想到的窥探方法，是使用 Instruments 的 Time Profile 功能。可以想象，解码一张大图一定是一个比较耗时的操作，很可能能被 Time Profiler 捕捉到。于是设计 Demo，果然在 Time Profiler 中发现了一个调用栈：<br>
<img src="https://xushuangqing.github.io/post-images/%5BUIImage-imageNamed-%5D--huan-cun-ce-lve-kui-tan/164542-2e6babb82708260a.png" alt="" loading="lazy"></p>
<p>用符号断点也可以验证，只有当即将有 UIImage 展示到屏幕上时，这个调用栈才会触发。因此假设，CUIUncompressDeepmap2ImageData 是解码（至少是我的 Asset Catalog 中的那张图解码）会走到的函数。</p>
<p>之后我们可以用符号断点 CUIUncompressDeepmap2ImageData 是否触发来验证一些缓存策略。</p>
<h2 id="问题二磁盘-io-发生的时机是什么">问题二：磁盘 IO 发生的时机是什么？</h2>
<p>一句话回答：第一次读取某个 Assets.car 时，会有 open 和 read 操作（推测是读取索引），但真正读图的时机，是解压的时机，也就是 UIImage 展示到屏幕上时。</p>
<p>使用 Instruments 的 File Activity，可以窥探 UIImage imageNamed: 是如何处理 IO 的，可以很容易地找到什么时间、什么调用栈读取了 Assets.car。<br>
<img src="https://xushuangqing.github.io/post-images/%5BUIImage-imageNamed-%5D--huan-cun-ce-lve-kui-tan/164542-82ba845909955367.png" alt="" loading="lazy"></p>
<p>结合符号断点也容易验证，第一次调用 [UIImage imageNamed:]，会触发 open 和 read 的系统调用。但之后再次从同一个 Assets.car 中获取 UIImage，open 和 read 就不再被调用了。<br>
<img src="https://xushuangqing.github.io/post-images/%5BUIImage-imageNamed-%5D--huan-cun-ce-lve-kui-tan/164542-b79efaf7bee70379.png" alt="" loading="lazy"><br>
<img src="https://xushuangqing.github.io/post-images/%5BUIImage-imageNamed-%5D--huan-cun-ce-lve-kui-tan/164542-70c5e74b4b6ed9bb.png" alt="" loading="lazy"></p>
<p>从内存占用和设计的合理性上看，这个 read 操作并不是一次性把 Assets.car 的内容都读到了内存中。结合 File Activity 中，大部分读取 Assets.car 的 Operation 是 Page In，说明真正读取图片数据，用的是内存映射的方式。</p>
<p>那么发生 Page In 的时机又是什么时候呢？是调用 [UIImage imageNamed:] 的时候，还是图片展示到屏幕上的时候呢？通过实验和堆栈可以推测，至少大部分的 Page In 的时机，是图片展示到屏幕上，也就是解码的时机。<br>
<img src="https://xushuangqing.github.io/post-images/%5BUIImage-imageNamed-%5D--huan-cun-ce-lve-kui-tan/164542-79a9feeb36c8f2ca.png" alt="" loading="lazy"></p>
<p>而且 Page In 时的堆栈也是 CUIUncompressDeepmap2ImageData。说明解码时，是一边从磁盘中 Page In 一边解码的。</p>
<h2 id="问题三缓存的内容是什么">问题三：缓存的内容是什么？</h2>
<p>一句话回答：缓存了 CGImage（如果已经解码，相当于缓存了 Bitmap），图片的 Data 通过内存映射也达到了缓存的目的。</p>
<p>首先我们可以用 Xcode Memory Graph 来窥探，CGImage 对象是被什么持有的。<br>
这时 Demo 中的图像已经不再展示在屏幕，已知的强持有也释放了，但 CGImage 对象依然存在内存中。这里能看到一条持有它的链条：<br>
<img src="https://xushuangqing.github.io/post-images/%5BUIImage-imageNamed-%5D--huan-cun-ce-lve-kui-tan/164542-4d6feab02a9fd4ca.png" alt="" loading="lazy"></p>
<p>最直接的是，CGImage 对象被 CUIStructuredThemeStore-&gt;_cache 持有着。<br>
CUIStructuredThemeStore-&gt;_cache 是一个字典，用 debugger 打印它的样例内容：</p>
<pre><code>po ((CUIStructuredThemeStore *)0x6000021f8c80)-&gt;_cache
{
    &quot;0{0-0-3-0-0-0-0-0-0-0-0-0-0-0-0-0-8019-55-b5-0-0&quot; = &quot;&lt;_CUIThemePixelRendition: 0x7ff18461cae0&gt; -- Rendition name: my_image_375x640_@3x.png&quot;;
}
</code></pre>
<p>怀疑这就是 imageNamed: 的缓存。</p>
<p>通过 <a href="https://developer.limneos.net/?ios=11.1.2&amp;framework=CoreUI.framework&amp;header=CUIStructuredThemeStore.h">CUIStructuredThemeStore 的头文件</a> 猜测和验证，CUIStructuredThemeStore 有一个</p>
<pre><code>NSCache* _namedRenditionKeyCache;
</code></pre>
<p>其中 key 是 Image Set 的名字，value 是一个 struct renditionkeytoken，这个 renditionkeytoken 可以通过 keySignatureForKey: 转换成 key signature（一个 NSString），即 _cache 字典的 key。</p>
<p>所以如果简化理解一下，图片的缓存是一个 NSDictionary，可以根据 Asset Catalog 中 Image Set 的名字，找到缓存的 CGImage 对象。</p>
<p>啊对了，Memory Graph 里，CUIStructuredThemeStore 还被一个 MapTable 持有，实验了一下，一个 MapTable 中的元素，对应了一个 Assets.car。也就是说如果 App 中有多个 Assets.car，它们的缓存是隔离的。</p>
<p>那图片的 Data 有没有缓存呢？由于 Data 使用的是内存映射的方式，重复读取并不会发生多次 Page In，只有当内存紧张时，这块映射的内存才会被 Page Out，因此相当于一个天然的缓存。</p>
<h2 id="问题四清理缓存的时机是什么">问题四：清理缓存的时机是什么？</h2>
<p>这里的“缓存”，仅讨论 CGImage 的缓存。<br>
一句话回答：至少退后台、memory warning 会触发清空，但猜测缓存大小没有限制。</p>
<p>从 <a href="https://developer.limneos.net/?ios=11.1.2&amp;framework=CoreUI.framework&amp;header=CUIStructuredThemeStore.h">CUIStructuredThemeStore 的头文件</a> 中，发现 CUIStructuredThemeStore 有个 clearRenditionCache 方法，看起来是用于清空缓存的。</p>
<p>符号断点验证，在 app 退后台、memory warning 时，clearRenditionCache 会触发，CUIStructuredThemeStore-&gt;_cache 也会被清空。</p>
<p><img src="https://xushuangqing.github.io/post-images/%5BUIImage-imageNamed-%5D--huan-cun-ce-lve-kui-tan/164542-50b5513b6df379e0.png" alt="" loading="lazy"><br>
<img src="https://xushuangqing.github.io/post-images/%5BUIImage-imageNamed-%5D--huan-cun-ce-lve-kui-tan/164542-c598246c42280dc0.png" alt="" loading="lazy"></p>
<p>缓存清理后，下次创建 UIImage 并展示到屏幕上时，解码的 CUIUncompressDeepmap2ImageData 也确实被调用了。</p>
<p>那缓存的大小是否有限制呢？我猜测是没有的。<br>
通过不断读取大图，我制造了缓存高达 600+MB 且还能继续上升的场景。结合缓存使用的 NSDictionary 而不是 NSCache，猜测在 memory warning 之前，缓存是可以持续增长的。</p>
<h2 id="总结">总结</h2>
<p>一句话总结一下开头的四个问题：</p>
<p>问题一：图片解码发生的时机是什么？<br>
在 UIImage 显示到屏幕上时。</p>
<p>问题二：磁盘 IO 发生的时机是什么？<br>
第一次读取某个 Assets.car 时，会有 open 和 read 操作（推测是读取索引），但真正读图的时机，是解压的时机，也就是 UIImage 展示到屏幕上时，利用的是内存映射。</p>
<p>问题三：缓存的内容是什么？<br>
缓存了 CGImage（如果已经解码，相当于缓存了 Bitmap），图片的 Data 通过内存映射也达到了缓存的目的。</p>
<p>问题四：清理缓存的时机是什么？<br>
至少退后台、memory warning 会触发清空，但猜测缓存大小没有限制。</p>
<p>其中磁盘 IO 的部分，尤其感受到了，自研缓存想要超越 Assets.car 并不是一件容易的事情。</p>
<p>那还有一个问题：我们能利用 [UIImage imageNamed:] 的缓存做些什么？<br>
一个启动优化的思路，是将启动期间需要读取的图片，预先在异步线程调用 imageNamed: 读取并画在一个画布上使它强制解码，等主线程真正要读取时，能减少主线程 Page In 和解码的开销。<br>
也许还能像二进制重排一样对 Assets.car 进行重排，进一步降低 Page In 的开销。</p>
<p>🤔</p>
<h3 id="相关资料">相关资料</h3>
<p><a href="https://dreampiggy.com/2019/01/18/%E4%B8%BB%E6%B5%81%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E9%A2%84%E8%A7%A3%E7%A0%81%E7%A9%B6%E7%AB%9F%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/#more">主流图片加载库所使用的预解码究竟干了什么</a><br>
<a href="https://juejin.im/post/5cb74d786fb9a068773948fc#heading-12">iOS拾遗—— Assets Catalogs 与 I/O 优化</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fishhook 原理浅析]]></title>
        <id>https://xushuangqing.github.io/post/Fishhook--yuan-li-qian-xi/</id>
        <link href="https://xushuangqing.github.io/post/Fishhook--yuan-li-qian-xi/">
        </link>
        <updated>2020-01-07T12:56:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-初识-fishhook">一、初识 fishhook</h2>
<p>Fishhook 是 facebook 的开源库。官方描述，它的作用是：</p>
<blockquote>
<p>... enables dynamically rebinding symbols in Mach-O binaries running on iOS in the simulator and on device</p>
<p>支持对 iOS 模拟器和设备上运行的 Mach-O 二进制文件，动态地重绑定其中的符号</p>
</blockquote>
<p>更浅显的解读是，如果你的程序调用了动态库中的函数 A，可以通过 fishhook，在运行时将“调用函数 A”改为“调用函数 B”。</p>
<p>Fishhook 的源码只有 250 行，因此可以方便地接入到业务中。</p>
<h2 id="二-c-函数调用也能篡改">二、C 函数调用也能篡改？</h2>
<p>我们能理解 OC 中 method swizzling 的原理。因为 OC 有一套运行时机制，因此给 OC 对象 obj 发送消息 call 时，要经过 runtime 的匹配，才能在运行时得出 call 方法的地址，让指令跳转到 call 方法内部。因此，只要在 runtime 匹配的过程中做手脚，就可以将 call 方法篡改为其他方法。</p>
<p>但是 C 语言中，调用某个函数，指令跳转到某个地址，这是在编译链接时就决定的。看起来我们并不能在运行时改变这个地址。</p>
<p>但实际上，如果调用的函数是动态库中的，那么，这个二进制程序，在启动前也并不知道动态库中这个函数的地址。这个地址也是运行时计算得到的。<br>
因此这就给 fishhook 提供了机会。</p>
<h2 id="三-正常函数的调用过程">三、正常函数的调用过程</h2>
<p>在了解 fishhook 做了什么之前，我们先一步一步看看，调用一个动态库里的 C 函数，会经过哪些步骤。</p>
<h3 id="31-macho-背景知识">3.1 MachO 背景知识</h3>
<p>在开始之前，我们先回顾一下 MachO 的背景知识。</p>
<blockquote>
<p>进程是特殊文件在内存中加载得到的结果</p>
</blockquote>
<p>一个 iOS app 的进程，就是 MachO 文件在内存中加载得到的结果。</p>
<figure data-type="image" tabindex="1"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-a6d3ba75e9b8f886.png" alt="" loading="lazy"></figure>
<p>比如这是一个 arm64 架构下的 MachO 文件。Mach 加载器会读取 MachO 文件中的加载命令（Load Commands），这些命令决定了如何布局这个进程的内存空间。</p>
<figure data-type="image" tabindex="2"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-33b2f09b9d0651e9.png" alt="" loading="lazy"></figure>
<p>（这里需要注意：内存地址和 MachO 文件的 offset 是两个概念，对于 TEXT 和 DATA 段中的东西，arm64 架构下，可以认为 0x100000000 + offset + ASLR = 内存地址）</p>
<h3 id="32-printf-调用的过程">3.2 printf() 调用的过程</h3>
<p>我们以 printf() 这个函数举例。</p>
<p>以下分析均在 arm64 架构下进行。</p>
<h4 id="调用-printf-的汇编是什么样">调用 printf() 的汇编是什么样</h4>
<p>我们知道，当发生一个函数调用时，编译器和静态链接器，会把这个函数调用，成“跳转到某个地址继续执行程序”。</p>
<p>那么我们首先看看调用 printf() 的汇编是什么样的。</p>
<figure data-type="image" tabindex="3"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-e8f004bc9067cd54.png" alt="" loading="lazy"></figure>
<p>首先，我们将 Xcode 设置为，断点时查看汇编。</p>
<p>然后在调用 printf() 时打一个断点。运行到这个断点时，我们看到了这样一行汇编代码：</p>
<figure data-type="image" tabindex="4"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-6b94d60cad57d1a6.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-f777ac3ec87afdc5.png" alt="" loading="lazy"></figure>
<pre><code>0x10044e694 &lt;+72&gt;: bl 0x10044ea78 ; symbol stub for: printf
</code></pre>
<p>意思是跳转到 0x10044ea78 地址继续执行，并且这个地址，代表了 printf 函数。</p>
<p>0x10044ea78 地址，实际是什么呢？</p>
<p>由于 ASLR 技术，我们需要减去 image 的起始地址，才能得到 rebase 之前的地址，用于和 MachO 文件对比。通过 image list 命令得到各个 image 的起始地址后，我们发现，0x10044ea78 落在起始地址为 0x0000000100448000 的主二进制中，二者相减，偏移量为 0x6a78</p>
<p>0x6ac8 位于 TEXT 段 __stubs 节。说明，调用 printf() 首先跳转到了代码段的某个地址上。</p>
<h4 id="去找符号表">去找符号表</h4>
<p>使用 otool -v XSQFishhookDemo -s __TEXT __stubs 查看，得到0x6a78 地址开始的指令为：</p>
<pre><code>0000000100006a78        nop
0000000100006a7c        ldr        x16, #0x15dc
0000000100006a80        br        x16
</code></pre>
<p>nop 为空命令</p>
<p>ldr 这一行的意思是，将当前 pc 寄存器中的值，加上 0x15dc，再存到 x16 寄存器中</p>
<p>br 这一行的意思是，跳转到 x16 寄存器的值指向的地址。</p>
<p>x16 寄存器中的值会是什么？根据 ldr 这一行算出，是 0000000100006a7c + 0x15dc = 0x8058</p>
<p>去查看 0x8058 这个地址，它位于 DATA 段 __la_symbol_ptr 节。</p>
<figure data-type="image" tabindex="6"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-1eca7149fd138a23.png" alt="" loading="lazy"></figure>
<p>__la_symbol_ptr 节是一系列指针，这些指针指向的，是某一个指令的地址。</p>
<p>这里 0x8058 这个地址中存的是 0x100006b08</p>
<p>这个 0x100006b08 是 MachO 还未 or 刚刚载入内存中时，内存中 0x100008058 地址存的值。但是内存中的值是可以被改变的。事实上，只有第一次调用 printf 的时候，这一步会跳转到 0x100006b08，之后，这个内存会被写入新的地址，即动态库中 printf() 函数的地址。</p>
<p>这就是 Lazy bind。</p>
<h4 id="lazy-bind">Lazy bind</h4>
<p>Fishhook 的 README 中介绍：</p>
<blockquote>
<p>__la_symbol_ptr is an array of pointers to imported functions that is generally filled by a routine called dyld_stub_binder during the first call to that symbol</p>
</blockquote>
<p>也就是说，这个 __la_symbol_ptr 节中的内容，在载入内存后，是一个函数指针的数组。</p>
<p>我们就来看看这个 0x8058 中存储的 0x100006b08，是一个什么样的函数指针。</p>
<p>0x100006b08 位于 __TEXT 段 __stub_helper 节，它的汇编指令是：</p>
<figure data-type="image" tabindex="7"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-bfff6d6b30e522d4.png" alt="" loading="lazy"></figure>
<pre><code>0000000100006b08        ldr        w16, 0x100006b10
0000000100006b0c        b        0x100006a84
</code></pre>
<p>接下来就会跳转到 0x6a84 这个地址。</p>
<p>这个地址是 __stub_helper 节的开头。</p>
<figure data-type="image" tabindex="8"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-a679436d88d03c6c.png" alt="" loading="lazy"></figure>
<p>执行几个指令后，就回去调用 dyld_stub_binder 函数</p>
<p>dyld_stub_binder 是 dyld 执行 bind 的函数。这个函数执行完后，__la_symbol_ptr 节中的内容，将不再是指向 __stub_helper 节的地址，而是 printf 函数真正的地址。</p>
<p>那么下次调用 printf 函数的时候，就可以直接通过 __la_symbol_ptr，找到真正的 printf 函数地址了。</p>
<h2 id="四-fishhook-做了什么">四、Fishhook 做了什么</h2>
<p>这时，我们想，如果把 __la_symbol_ptr 中存的地址改了，那是不是就能把 printf 函数指向其它一段指令了呢？</p>
<p>Fishhook 也是这样想的。</p>
<p>所以 Fishhook 的原理，也是篡改内存中 __la_symbol_ptr 中的内容。把原本应该存 printf() 地址的那块内存，内容改为 my_printf() 地址。</p>
<p>那么问题来了，我们能用函数指针的方式，知道 my_printf() 的地址，但是我们怎么知道，__la_symbol_ptr 中的第几个元素，表示的是 printf() 的地址呢？</p>
<p>如果我们能知道 __la_symbol_ptr 中的第 n 个元素，表示的函数的名字，那我们可以遍历 __la_symbol_ptr 数组，找到表示 printf() 的那个。</p>
<p>于是现在问题变成了，我们怎么知道 __la_symbol_ptr 中的每个元素表示的函数的名字呢？</p>
<p>这里就有一个规律：</p>
<figure data-type="image" tabindex="9"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-35cb26020f2205c7.png" alt="" loading="lazy"></figure>
<p>我们再用 printf() 来走一遍这个流程，验证一番。</p>
<h3 id="41-找到对应函数名">4.1 找到对应函数名</h3>
<h4 id="__la_symbol_ptr-indirect-symbols">__la_symbol_ptr --&gt;  Indirect Symbols</h4>
<p>MachO 文件有个规律，__la_symbol_ptr 节中的第 i 个数据，在 Indirect Symbols 中有对应的体现，且 index 变成了 reserved0 + i。</p>
<p>printf() 对应的数据，在 __la_symbol_ptr 节中是第 10 个元素，__la_symbol_ptr 中的 reserved1 为 12，那么我们找到 Indirect Symbols 中的第 22 个元素：</p>
<figure data-type="image" tabindex="10"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-f4cf0cb42326d95b.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-b536c8aa302822a7.png" alt="" loading="lazy"></figure>
<p>这里的值是 0x50</p>
<h4 id="indirect-symbols-symbol-table">Indirect Symbols --&gt; Symbol Table</h4>
<p>我们拿着 0x50，去 Symbol Table 中找到 Symbol Table 中 index = 0x50 的数据。</p>
<figure data-type="image" tabindex="12"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-3c353870cd6b86f5.png" alt="" loading="lazy"></figure>
<p>得到 0x233</p>
<h4 id="symbol-table-string-table">Symbol Table --&gt; String Table</h4>
<p>Symbol Table 中偏移量为 0x233 的字符串，就是 _printf</p>
<figure data-type="image" tabindex="13"><img src="https://xushuangqing.github.io/post-images/Fishhook--yuan-li-qian-xi/164542-a84d10416069c30a.png" alt="" loading="lazy"></figure>
<p>这样，主 binary 就知道，__la_symbol_ptr 节中的第 10 个元素，代表 printf，</p>
<h3 id="42-篡改-__la_symbol_ptr-中的数据">4.2 篡改 __la_symbol_ptr 中的数据</h3>
<p>这样，fishhook 只要遍历一次 __la_symbol_ptr，当发现第 i 个元素对应的名字，就是我们要 hook 的名字时，就可以将 __la_symbol_ptr 中的第 i 个元素的值篡改掉，完成 hook 的过程。</p>
<h2 id="参考资料">参考资料</h2>
<p>Fishhook 源码：<a href="https://github.com/facebook/fishhook">https://github.com/facebook/fishhook</a></p>
<p>iOS逆向(6)-从fishhook看runtime，hook系统C函数 <a href="https://www.jianshu.com/p/b6a72aa6c146">https://www.jianshu.com/p/b6a72aa6c146</a></p>
<p>Dyld之二: 动态链接过程：<a href="https://blog.cnbluebox.com/blog/2017/10/12/dyld2/">https://blog.cnbluebox.com/blog/2017/10/12/dyld2/</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/413/">App Startup Time: Past, Present, and Future</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2016/406/?time=1154">Optimizing App Startup Time</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FBRetainCycleDetector遇到NSMapTable的crash---从发现到PR]]></title>
        <id>https://xushuangqing.github.io/post/FBRetainCycleDetector-yu-dao-NSMapTable-de-crash----cong-fa-xian-dao-PR/</id>
        <link href="https://xushuangqing.github.io/post/FBRetainCycleDetector-yu-dao-NSMapTable-de-crash----cong-fa-xian-dao-PR/">
        </link>
        <updated>2019-07-17T12:56:09.000Z</updated>
        <content type="html"><![CDATA[<p>自从项目接入了 MLeaksFinder + FBRetainCycleDetector 的内存泄漏检测方案，在收获了许多有效内存泄漏的同时，我们也收获了两个 FBRetainCycleDetector 的 crash。</p>
<p>首先抛出这两个 crash 的调用栈：</p>
<p>问题1：</p>
<pre><code>Crashed: com.mapp.cycleDetector
0  libobjc.A.dylib                0x1903be058 objc_retain + 8
1  MAppInHouse                    0x10594e1ac FBWrapObjectGraphElement + 64 (FBRetainCycleUtils.m:64)
2  MAppInHouse                    0x10594c324 -[FBObjectiveCObject allRetainedObjects] + 83 (FBObjectiveCObject.m:83)
3  MAppInHouse                    0x10594a868 -[FBNodeEnumerator nextObject] + 34 (FBNodeEnumerator.mm:34)
4  MAppInHouse                    0x10594d0a8 -[FBRetainCycleDetector _findRetainCyclesInObject:stackDepth:] + 132 (FBRetainCycleDetector.mm:132)
5  MAppInHouse                    0x10594caac -[FBRetainCycleDetector findRetainCyclesWithMaxCycleLength:] + 65 (FBRetainCycleDetector.mm:65)
6  MAppInHouse                    0x1061c4174 __55-[NSObject(MemoryLeak) checkRetainCycleWithCompletion:]_block_invoke.165 + 256 (NSObject+MemoryLeak.m:256)
7  libdispatch.dylib              0x190348678 _dispatch_call_block_and_release + 24
8  libdispatch.dylib              0x1903491ec _dispatch_client_callout + 16
9  libdispatch.dylib              0x19032675c _dispatch_lane_serial_drain$VARIANT$armv81 + 564
10 libdispatch.dylib              0x190327178 _dispatch_lane_invoke$VARIANT$armv81 + 404
11 libdispatch.dylib              0x1903304bc _dispatch_workloop_worker_thread + 576
12 libsystem_pthread.dylib        0x190398f5c _pthread_wqthread + 304
13 libsystem_pthread.dylib        0x19039baa0 start_wqthread + 8
</code></pre>
<p>问题2：</p>
<pre><code>Crashed: com.mapp.cycleDetector
0  CoreFoundation                 0x21f4c37e0 ___forwarding___ + 1448
1  CoreFoundation                 0x21f4c546c _CF_forwarding_prep_0 + 92
2  MAppInHouse                    0x1018e70d4 FBWrapObjectGraphElementWithContext + 43 (FBRetainCycleUtils.m:43)
3  MAppInHouse                    0x1018e72f4 FBWrapObjectGraphElement + 65 (FBRetainCycleUtils.m:65)
4  MAppInHouse                    0x1018e5454 -[FBObjectiveCObject allRetainedObjects] + 83 (FBObjectiveCObject.m:83)
5  MAppInHouse                    0x1018e3998 -[FBNodeEnumerator nextObject] + 34 (FBNodeEnumerator.mm:34)
6  MAppInHouse                    0x1018e61d8 -[FBRetainCycleDetector _findRetainCyclesInObject:stackDepth:] + 132 (FBRetainCycleDetector.mm:132)
7  MAppInHouse                    0x1018e5bdc -[FBRetainCycleDetector findRetainCyclesWithMaxCycleLength:] + 65 (FBRetainCycleDetector.mm:65)
8  MAppInHouse                    0x10215d2a4 __55-[NSObject(MemoryLeak) checkRetainCycleWithCompletion:]_block_invoke.165 + 256 (NSObject+MemoryLeak.m:256)
9  libdispatch.dylib              0x21eef56c8 _dispatch_call_block_and_release + 24
10 libdispatch.dylib              0x21eef6484 _dispatch_client_callout + 16
11 libdispatch.dylib              0x21eed0fa0 _dispatch_lane_serial_drain$VARIANT$armv81 + 548
12 libdispatch.dylib              0x21eed1ae4 _dispatch_lane_invoke$VARIANT$armv81 + 412
13 libdispatch.dylib              0x21eed9f04 _dispatch_workloop_worker_thread + 584
14 libsystem_pthread.dylib        0x21f0d90dc _pthread_wqthread + 312
15 libsystem_pthread.dylib        0x21f0dbcec start_wqthread + 4
</code></pre>
<p>FBRetainCycleDetector 是 facebook 出品的寻找循环引用的工具。简单来说，它通过<code>class_copyIvarList</code>获取一个类的实例变量列表，使用<code>class_getIvarLayout</code>判定是实例变量是否为强引用，然后使用有向图中找环的算法，获取循环引用的引用环。</p>
<p>光从调用栈上来看，我们对这一问题没有头绪。首先，这两个 crash 并非必现；其次，从崩溃用户的行为上看，也没有发现共性。</p>
<p>作为一个 facebook 出品，经过了多年验证的三方库，我们判断这两个 crash 并非一般的代码逻辑问题。解决这两个问题看起来会是一个挑战。</p>
<h2 id="错误的判断">错误的判断</h2>
<p>一开始我们以为问题 1 是一个多线程的问题，因为 FBRetainCycleDetector 有一段注释，表明它的确可能存在多线程问题，只是用 try catch 尝试缩小它的影响。</p>
<p>同时，问题 1 的调用栈中，的确有多个线程在进行找环操作。</p>
<figure data-type="image" tabindex="1"><img src="https://xushuangqing.github.io/post-images/FBRetainCycleDetector-yu-dao-NSMapTable-de-crash----cong-fa-xian-dao-PR/164542-9092e8bf9d3cf455.png" alt="" loading="lazy"></figure>
<p>我们曾尝试通过将并发队列改为串行队列的方式修复问题1，但是并未修好。</p>
<h2 id="线索">线索</h2>
<h3 id="来自-github-issue">来自 github issue</h3>
<p>遇到疑难问题，特别是开源库的问题，我们迅速反应出，去网络上尝试寻找解决方案。</p>
<figure data-type="image" tabindex="2"><img src="https://xushuangqing.github.io/post-images/FBRetainCycleDetector-yu-dao-NSMapTable-de-crash----cong-fa-xian-dao-PR/164542-0d2625ceee51df99.png" alt="" loading="lazy"></figure>
<p>https://github.com/facebook/FBRetainCycleDetector/issues/60#issuecomment-503511056</p>
<p>从 FBRetainCycleDetector 的 github issue 上，我们发现了一个与问题1类似的问题描述。其中，提问者提到，这是遍历 NSMapTable 时遇到的。</p>
<p>NSMapTable 是我们获得的第一个线索。</p>
<h3 id="一次偶然的复现">一次偶然的复现</h3>
<p>同时，我们在调试时，也偶然复现了一次问题2。这次复现给了我们关键的信息。</p>
<figure data-type="image" tabindex="3"><img src="https://xushuangqing.github.io/post-images/FBRetainCycleDetector-yu-dao-NSMapTable-de-crash----cong-fa-xian-dao-PR/164542-fe13cdd2a8854a41.png" alt="" loading="lazy"></figure>
<p>当时的现场是，正在找环过程中的object对象变成了一个指向0xffffffffffffffff地址的指针，而这个指针通过object_getClass竟然能取到对应的类，对应的类是<code>__NSAtom</code>。</p>
<p><code>__NSAtom</code>显然是一个私有类，而且它不继承自<code>NSObject</code>，没有<code>isSubclassOfClass:</code>方法，所以执行到这里的时候，触发消息转发最后<code>EXC_BREAKPOINT</code>了。</p>
<p>此时，我们想到了一个最简单的修复方式：在这里绕过<code>isSubclassOfClass:</code>方法，使用 runtime 的 API <code>class_getSuperclass</code> 来达到判断是否是子类的目的。</p>
<figure data-type="image" tabindex="4"><img src="https://xushuangqing.github.io/post-images/FBRetainCycleDetector-yu-dao-NSMapTable-de-crash----cong-fa-xian-dao-PR/164542-5c074d2f3b45a655.png" alt="" loading="lazy"></figure>
<p>但是，不查明这个0xffffffffffffffff的由来，只修复问题的表面，也让我们心虚。0xffffffffffffffff显然是一个不符合预期的地址，而随意访问这种地址，可能会引爆更大的雷。</p>
<p>所以，我们不得不对这个问题做更多分析。</p>
<h2 id="稳定复现">稳定复现</h2>
<p>刚才的线索中，我们得到了两个重要信息：</p>
<ol>
<li>NSMapTable 是问题的来源</li>
<li>一个莫名其妙的数被当成了对象的地址</li>
</ol>
<p>已知的是，NSMapTable 作为一个功能更强大的容器，不仅仅可以存放对象，还能存放一个简单的数字。所以，我们尝试用 NSMapTable 来稳定复现问题2。</p>
<p>复现的方式其实很简单。</p>
<p>创建一个NSPointerFunctionsOpaqueMemory类型的容器，往容器里塞入 -1 这个数，也就是 0xffffffffffffffff，然后让这个容器被找环算法遍历到。</p>
<pre><code>xsqView.table = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsOpaqueMemory | NSPointerFunctionsIntegerPersonality valueOptions:0 capacity:0];
NSInteger i = -1;
[xsqView.table setObject:@&quot;hahaha&quot; forKey:(__bridge id)((void *)i)];
</code></pre>
<p>问题2被复现了出来。</p>
<p>而将这个数从 -1 改到 1，我们发现问题1也成了必现。</p>
<p>问题1和问题2，预期是同一个本质问题引起的。</p>
<h2 id="分析问题1">分析问题1</h2>
<p>稳定复现后，问题1的分析变得顺利了起来。</p>
<p>数字 “1” 被 FBRetainCycleDetector 遍历到的时候，FBRetainCycleDetector 使用了__strong 的 id 类型修饰它，导致运行时被调用了 <code>_objc_retain</code>，因此导致了 BAD ACCESS。</p>
<figure data-type="image" tabindex="5"><img src="https://xushuangqing.github.io/post-images/FBRetainCycleDetector-yu-dao-NSMapTable-de-crash----cong-fa-xian-dao-PR/164542-20f6acf2f331d987.png" alt="" loading="lazy"></figure>
<p>如果将这里的 id ，和 FBWrapObjectGraphElement 函数参数中的 id，都修改为 __unsafe_unretained id，这个 crash 堆栈立马变到了下一处对数字 “1” 进行强引用的地方。</p>
<p>所以问题1的本质原因被找到且证明了。FBRetainCycleDetector 并没有考虑到  NSPointerFunctionsOpaqueMemory 类型的容器，将容器内的元素都当作了对象来对待导致了问题1。</p>
<h2 id="分析问题2">分析问题2</h2>
<p>问题1的分析比较容易。但为什么将数字 &quot;1&quot; 改成 &quot;-1&quot; 后，问题1中 BAD ACCESS 的代码被顺利走过了，crash 堆栈变成了问题2呢？</p>
<p>搜索了一些资料，发现这是 tagged pointer 搞的鬼。</p>
<p>简单说，计算机中有内存对齐的说法，因此正常的指针，在 64 位设备上，最后 4 bit 必然是0。如果最后 4 bit 不是 0，说明这不是一个正常的指针。这个特性被苹果用于了tagged pointer。</p>
<p>（ http://www.phrack.org/issues/69/9.html 我从这篇博客里了解了一下tagged pointer）</p>
<p>由于一个对象的结构体中的第一个成员是 isa 指针，因此，如果 0xffffffffffffffff 被当作了一个对象，那么它实际也被当作了一个 isa 指针的值。而显然，这个 isa 指针还是个 tagged pointer。</p>
<p>如果一个 isa 指针是一个 tagged pointer 的话，它找到的 Class 的过程中会经历一个映射。经过映射，它最后可以被翻译为某一个属于 TaggerPointer 的类，比如 __NSAtom。所以，就出现了问题 2 中的崩溃栈。</p>
<p>（我们可以从开源的runtime代码中了解映射的过程https://opensource.apple.com/source/objc4/objc4-551.1/runtime/objc-private.h）</p>
<h2 id="问题根源">问题根源</h2>
<p>其实，通过分析 FBRetainCycleDetector 的找环逻辑，我们会发现，这些 “数字” 本来就不应该被遍历到。</p>
<p>因为存储了 NSPointerFunctionsOpaqueMemory 元素的容器，容器持有容器内元素的关系，并不是强引用。</p>
<p>FBRetainCycleDetector 其实也考虑到了这点，它有一个方法来判断容器是不是强引用：<br>
<img src="https://xushuangqing.github.io/post-images/FBRetainCycleDetector-yu-dao-NSMapTable-de-crash----cong-fa-xian-dao-PR/164542-fa811bfba0d7cc84.png" alt="" loading="lazy"></p>
<p>但是对于 NSPointerFunctionsOpaqueMemory 的容器，usesWeakReadAndWriteBarriers 属性返回的是 NO，所以被误判成了强引用。</p>
<h2 id="解决">解决</h2>
<p>NSPointerFunctions 没有开放接口判断它的 option 是什么。看起来我们无法分辨出 NSPointerFunctions 与元素的引用关系。但是在分析了 NSPointerFunctions 的接口文档后，我们发现了一个 trick 但合理的方案，就是利用它的 acquireFunction 属性。</p>
<p>官方文档是这样描述 acquireFunction 属性的。</p>
<blockquote>
<p>The function used to acquire memory.</p>
</blockquote>
<blockquote>
<p>This specifies the function to use for copy-in operations.</p>
</blockquote>
<p>这个属性是一个函数指针，当一个值被存入容器时，会调用这个函数，按需去 retain 这个即将被存入容器的元素。</p>
<p>我们做了个实验了。如果 option 是 NSPointerFunctionsStrongMemory，则这个 acquireFunction 是系统提供的函数，如果 option 是 NSPointerFunctionsOpaqueMemory，这个 acquireFunction 是空。</p>
<figure data-type="image" tabindex="6"><img src="https://xushuangqing.github.io/post-images/FBRetainCycleDetector-yu-dao-NSMapTable-de-crash----cong-fa-xian-dao-PR/164542-0ac169e262de6f44.png" alt="" loading="lazy"></figure>
<p>这个结果很好理解，也符合正常程序员的设计思路，当容器不想对存入的值做内存上的操作，什么也不干就行了。</p>
<p>所以我们可以推断，如果 acquireFunction 为空，说明这个容器并不会对元素的引用计数去 +1，这说明对元素的引用关系，并非是强引用。</p>
<p>当然这个论断反过来并不能推定。</p>
<p>所以我们可以在 FBRetainCycleDetector 的逻辑里加一个判断：</p>
<p>当容器的 NSPointerFunctions 的 acquireFunction 为空时，至少能说明它不会强引用存储的元素。可以直接放弃遍历其内部的元素。</p>
<h2 id="验证">验证</h2>
<p>我们已经通过获取 acquireFunction 达成了如上推断，为了进一步验证，我们用 Hopper 查看了逆向出来的伪代码，发现至少在 iOS 12.3.1 上，我们的推测是正确的。</p>
<p>我们不能保证 NSPointerFunctionsOpaqueMemory 的容器的 acquireFunction 在任何版本的 iOS 上都是空，但是增加对 acquireFunction 的判断好过什么也不做。</p>
<h2 id="提交">提交</h2>
<p>这个修复被首先提交到了项目中进行验证。证明修复有效后，我们给开源的 FBRetainCycleDetector 提交了同样的修复：</p>
<p>https://github.com/facebook/FBRetainCycleDetector/pull/79</p>
<p>同时在 FBRetainCycleDetector 的单元测试里增加了必现问题1的case。</p>
<h2 id="总结">总结</h2>
<p>在这个问题发现的初期，我抱着绝望的态度，认为开源库中的 crash 必然难解。但是事实证明，通过收集线索、耐心分析问题、制造必现场景、理解 root cause、大胆假设小心验证，问题依然是有机会解决的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实锤证明Fabric OOM free session的误报]]></title>
        <id>https://xushuangqing.github.io/post/shi-chui-zheng-ming-Fabric-OOM-free-session-de-wu-bao/</id>
        <link href="https://xushuangqing.github.io/post/shi-chui-zheng-ming-Fabric-OOM-free-session-de-wu-bao/">
        </link>
        <updated>2019-06-18T15:45:20.000Z</updated>
        <content type="html"><![CDATA[<p>Fabric 是业界著名的 crash 监控平台，国内外均有不少 app 使用 Fabric 进行 crash 和其他稳定性数据的监控。其中，OOM 率数据也是深受大家关注的数据之一。</p>
<p>但现在，我们通过各 app 间 OOM 率对比、猜测和验证，实锤证明了 Fabric 的 OOM 率有重大误报问题。其中最主要的误报是：Fabric 将用户正常的后台启动误判为了 OOM，导致各 app 的 OOM 率均是大幅偏高的。</p>
<h2 id="oom-率对比">OOM 率对比</h2>
<p>Fabric 检测 OOM 的原理，参考自 Facebook 的一篇文章：https://code.fb.com/ios/reducing-fooms-in-the-facebook-ios-app/</p>
<p>它在 app 每次启动时，判断了 app 上次进程结束的原因，排除掉 首次安装、app升级、系统升级、crash等原因，最后筛选出前台 OOM 的用户。</p>
<p>Fabric也在文档中特意强调，他们的 OOM-free-session 指标，使用的是前台 OOM 率。也就是说，被 Fabric 捕获到的 OOM 用户，其用户体验预期是与 crash 同样严重的。</p>
<pre><code> We only report the OOM if the app was in the foreground before the second launch. 
</code></pre>
<p>但我们经手的多个产品，在 Fabric 平台上体现的 OOM 率，都比直观感受高很多，在百分之的量级。并且多个产品之间的 OOM 率有明显差距。如果线上用户的实际体验真是如此，那么 OOM 问题的确是非常严重、亟待解决的问题。</p>
<h2 id="猜测">猜测</h2>
<p>为了定位 OOM 问题，我们曾根据 Facebook 描述的原理，自研过 OOM 监控功能。我们期望通过追查单个用户 OOM 前的操作行为去定位 OOM 发生场景的共性。但当时，我们惊奇地发现，很多用户的行为是：启动 - 再次启动。看起来是用户在启动阶段，就遭遇了 OOM 问题。</p>
<p>这样的用户行为给我们带来了很大困扰。直到我们发现，自研的 OOM 监控中，默认将 app 启动后的状态置为了 foreground 状态。从代码上推测，当用户因 background fetch 等机制触发后台启动时，就有可能被自研 OOM 监控模块判定为 OOM。</p>
<p>对此，我们快速进行了验证，发现，后台启动的确会被自研 OOM 监控判定为前台 OOM。修复这一问题后，我们也对比发现，Fabric 的 OOM 率和 自研组件监控到的OOM率，相差甚远。</p>
<p>于是我们怀疑，Fabric 是不是和我们一开始犯了同样的错误，默认 app 启动后即进入前台，从而将后台启动误判为 OOM 呢？</p>
<h2 id="验证">验证</h2>
<p>我们对于以上猜测进行了验证。</p>
<p>由于 Fabric 的 OOM 数据，只有 “版本的 OOM-free-session” 这一项，没有提供更详细的信息，也无法单点追查，我们只能通过打一个特殊版本号的包的方式实验。</p>
<p>至于如何让 app 后台唤起，我们使用的是推送带选项通知的手段。用户在通知中心做这些操作，实际会让 app 在后台短暂唤起。<br>
<img src="https://xushuangqing.github.io/post-images/shi-chui-zheng-ming-Fabric-OOM-free-session-de-wu-bao/164542-d8c9949f26d7d131.png" alt="" loading="lazy"></p>
<p>用这个特殊版本号的包，操作了若干次后台唤起。两天后，我们果然在 Fabric 平台上看到了这个特殊版本号的包，被检测到了 5 次 OOM。但实际上，整个过程中，此包没有遇到任何一次真正的前台 OOM。<br>
<img src="https://xushuangqing.github.io/post-images/shi-chui-zheng-ming-Fabric-OOM-free-session-de-wu-bao/164542-4525e82517e7006f.png" alt="" loading="lazy"></p>
<p>据此，我们可以证明，Fabric 至少将用户正常的后台唤起，误报为了 OOM。这显然会造成严重的 OOM 率虚高问题。</p>
<p>与我们有同样困扰的开发者也存在，在追查期间，我们也在 StackOverFlow 上找到了类似的讨论：https://stackoverflow.com/questions/48121843/suddenly-getting-many-fabric-out-of-memory-sessions-can-fabric-oom-reports-ever</p>
<p>而除了将正常后台唤起误报为 OOM 之外，我们从原理和文档上还能判断出，Fabric 至少还将 exit 和 watchdog 误报成了 OOM。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用户在 app store 上看到的包大小究竟是什么？]]></title>
        <id>https://xushuangqing.github.io/post/yong-hu-zai--app-store--shang-kan-dao-de-bao-da-xiao-jiu-jing-shi-shen-me-？/</id>
        <link href="https://xushuangqing.github.io/post/yong-hu-zai--app-store--shang-kan-dao-de-bao-da-xiao-jiu-jing-shi-shen-me-？/">
        </link>
        <updated>2019-05-28T12:47:38.000Z</updated>
        <content type="html"><![CDATA[<p>在做安装包大小优化前，我们应该首先搞清楚，用户在 app store 上看到的包大小，究竟是什么？</p>
<p>如果我们衡量安装包大小的口径，和用户看到的大小不一致，那么做优化时的优先级和ROI衡量就可能跑偏，甚至出现优化效果为负的悲惨结局。</p>
<p>首先抛出结论：用户在 app store 上看到的包大小，是：</p>
<ul>
<li>.app 文件</li>
<li>的二进制部分被加壳后</li>
<li>再经过 app slicing</li>
</ul>
<p>的大小。</p>
<h2 id="如何查看">如何查看</h2>
<p>在某个版本的 app 上线之前，开发者应该如何知晓它在用户眼中的大小呢？<br>
苹果的 itunes connect 后台为开发者提供了查看安装包大小的功能。</p>
<p>在 itunes connect 后台，开发者可以看到当前版本针对不同机型的大小。</p>
<figure data-type="image" tabindex="1"><img src="https://xushuangqing.github.io/post-images/yong-hu-zai--app-store--shang-kan-dao-de-bao-da-xiao-jiu-jing-shi-shen-me-%EF%BC%9F/164542-b5d90389dd33d56d.png" alt="" loading="lazy"></figure>
<p>这里的大小分为两个口径：<br>
Download Size 和 Install Size。</p>
<p>根据网页上的说明：<br>
Install Size 是这个 app 安装后，会占用的磁盘大小；<br>
Download Size 是 app 经过压缩后的大小。</p>
<p>根据经验，用户在 app store 上看到的大小，就是 itunes connect 后台中显示的 Install Size。</p>
<p>而令开发者在意的，“超过 150 MB 的 app 必须连接至无线局域网才能下载”的规则中的 150 MB，指的其实是 Download Size。</p>
<h2 id="几个口径">几个口径</h2>
<p>Download Size 和 Install Size 是如何计算出来的，我们等下再说。</p>
<p>抛开 itunes connect 和 app store，平时我们在开发打包一个 app 时，经常会接触到这样几个安装包概念：</p>
<ul>
<li>ipa</li>
<li>app</li>
</ul>
<p>ipa 可能是我们最熟悉的“安装包”的格式。通过 Xcode 的 archive 方式，最终打出的安装包的格式就是 ipa。<br>
实际上，ipa 就是一个 zip 压缩包。我们可以用 unzip 的方式来解压一个 ipa 文件。</p>
<p>这样，我们会得到一个后缀名为.app的文件。</p>
<p>甚至可以想进入一个文件夹一样进入到这个.app中，窥探二进制、各个资源分别占据了多少大小。</p>
<p>这里我们知道了，.app 文件和 .ipa 文件的关系：<br>
ipa 文件是 app 文件 zip 压缩后的产物。</p>
<h2 id="用户看到的大小">用户看到的大小</h2>
<p>那么用户看到的 Install Size，究竟是 .app 文件的大小，还是 .ipa 文件的大小呢？<br>
答案：都不是。但是 .app 文件的大小与 Install Size 的口径更为接近。</p>
<h3 id="加壳">加壳</h3>
<p>苹果在 iOS 9 推出了能减小安装包的 app thining 功能。我们先不考虑这个功能，看看 iOS 9 以前 Install Size 与 .app 文件的关系。</p>
<p>要获取 app store 上的安装包，其实没有正规的做法。有一个比较trick的技巧可以获得：<br>
https://www.jianshu.com/p/ce018473fad0</p>
<p>通过这个方式，我们可以下载到一个 .ipa 文件。<br>
这个 ipa 文件经解压后得到的 app 文件，其大小与 iOS 9 以下设备在 app store 上看到的大小是吻合的。也与 itunes connect 中，开发者看到的 Install Size 是吻合的。</p>
<p>但是，它与开发者提交到 itunes connect 前的 app 文件大小，是有一定差距的。</p>
<p>比如，我们提交到 app store 上的 ipa 解压后的大小为 297.1MB<br>
从 app store 上下载的 ipa 解压后大小为 301.9MB</p>
<p>其中这 3.8 MB 的大小差异来自哪里呢？<br>
来自加壳。</p>
<p>我们对比了这两个 app 包中的各个文件大小，发现各资源文件的大小完全一致，只有二进制文件的大小发生了改变。</p>
<p>使用 otool 命令</p>
<pre><code>otool -l 可执行文件路径 | grep crypt
</code></pre>
<p>我们可以验证，app store 中下载的包经过了加壳，而提交 itunes connect 前的包没有。</p>
<p>使用</p>
<pre><code>otool -l
</code></pre>
<p>命令可以输出 Mach-O 文件加载的 load command。经对比发现，虽然加壳改变了TEXT段的内容，却没有改变TEXT段的大小。这 3.8 MB 的大小差异主要来自 __LINKEDIT 和 LC_CODE_SIGNATURE 这两个段，这两个段都与动态链接器有关。</p>
<p>因此，我们可以得到结论：iOS 9 之前，用户看到的 Install Size 的大小，是 .app 文件经过加壳的大小，粗略的可以认为就是 .app 文件的大小。</p>
<h3 id="app-slicing">app slicing</h3>
<p>上述的分析针对于 iOS 9 以下设备看到的情况。</p>
<p>如果考虑苹果在 iOS 9 上推出的 app thining 功能，安装包大小会有什么影响呢？</p>
<p>我们先了解一下，如果没有 app thining，一个安装包中会包含哪些内容。</p>
<p>对二进制来说，由于一个安装包需要同时支持 iPhone 5 等 32 位设备和 iPhone 5s 以上的 64 位设备，所以二进制中需要包含 armv7 和 arm64 两个架构的 Mach-O 文件。</p>
<p>对于放在 asset catalog 中的资源来说，一般来说，开发者为了更好的适配 iPhone 6 等 2x 屏幕的设备和 iPhone 6 plus 等 3x 屏幕的设备，每一个图片资源会引入 2x 和 3x 两个版本。</p>
<p>对于其他图片/资源来说，它们也会被收入到安装包中。</p>
<p>这里，我们可以明显发现，如果一个设备下载安装了安装包中的全部内容，有两个明显浪费的地方：</p>
<ol>
<li>有一份它不需要的 Mach-O</li>
<li>有一份它不需要的资源图</li>
</ol>
<p>苹果在 iOS 9 推出的 app slicing，就帮助开发者将这两个浪费的地方干掉了。</p>
<p>对于资源图，官方文档中有说明：<br>
A thinned .ipa is a compressed app bundle that contains only the resources needed to run the app on a specific device.<br>
https://developer.apple.com/library/archive/qa/qa1795/_index.html</p>
<p>对于二进制，我们没有在官方文档中找到说明。但 WWDC App Thinning in Xcode 一篇中这样介绍了 app slicing 功能:</p>
<figure data-type="image" tabindex="2"><img src="https://xushuangqing.github.io/post-images/yong-hu-zai--app-store--shang-kan-dao-de-bao-da-xiao-jiu-jing-shi-shen-me-%EF%BC%9F/164542-0208f48fc6c8dc31.png" alt="" loading="lazy"></figure>
<p>这张图中体现了，无论是二进制还是 asset catalog 中的资源，app slicing 都只保留了当前设备所需的部分。</p>
<p>而在导出 ipa 时，在配置 plist 文件中加入 <thin-for-all-variants> 选项，则可以导出针对不同机型的 ipa 文件。经实验，这些 ipa 文件解压后得到的 app 文件大小，与 itunes connect 后台各个设备对应的 Install Size 是吻合的。</p>
<h2 id="优化建议">优化建议</h2>
<p>正如文章开头的结论：</p>
<p>用户在 app store 上看到的包大小，是：</p>
<ul>
<li>.app 文件</li>
<li>的二进制部分被加壳后</li>
<li>再经过 app slicing</li>
</ul>
<p>的大小。</p>
<p>得知了用户看到的包大小究竟是什么含义，我们可以避开一些包大小优化的坑。</p>
<p>比如，由于 app slicing 的存在，图标应该尽可能用 asset catalog 管理起来。所以试图用 webp 等格式来替代 asset catalog，可能是负向收益。<br>
（这个思路经过实验，结论是，在我们的业务场景下，如果用 webp 替代 asset catalog，对于 2x 设备的 Download Size 是负向收益，因为 2x 设备不得不使用 3x 的图片，并且 webp 图的压缩率比 asset catalog 低很多）</p>
<p>再比如，不要幻想抛弃 armv7 架构的设备，可以减小包大小。苹果已经帮开发者做过这一步了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[YYThreadSafeArray在多线程方面的若干问题]]></title>
        <id>https://xushuangqing.github.io/post/YYThreadSafeArray-zai-duo-xian-cheng-fang-mian-de-ruo-gan-wen-ti--1/</id>
        <link href="https://xushuangqing.github.io/post/YYThreadSafeArray-zai-duo-xian-cheng-fang-mian-de-ruo-gan-wen-ti--1/">
        </link>
        <updated>2019-03-13T03:39:43.000Z</updated>
        <content type="html"><![CDATA[<p>YYThreadSafeArray是YYKit中的一个工具类，旨在提供线程安全的数组。YYThreadSafeArray的原理是继承NSMutableArray的，并且对其中必要的方法加锁来保证线程安全。但是，虽然YYKit在开源界使用广泛，但是YYThreadSafeArray依然有一些多线程方面的问题。其中部分问题在我们的项目中暴露和修复。</p>
<h2 id="问题1调用枚举方法导致死锁">问题1：调用枚举方法导致死锁</h2>
<h3 id="调用方式">调用方式：</h3>
<pre><code>YYThreadSafeArray *array = [[YYThreadSafeArray alloc] initWithObjects:@&quot;hello world&quot;, nil];
[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    [array count];
}];
</code></pre>
<h3 id="导致问题">导致问题：</h3>
<p>死锁。<br>
<img src="https://xushuangqing.github.io/post-images/YYThreadSafeArray-zai-duo-xian-cheng-fang-mian-de-ruo-gan-wen-ti--1/164542-80536b0d88d6fd5d.png" alt="" loading="lazy"></p>
<h3 id="原因分析">原因分析：</h3>
<p>YYThreadSafeArray使用加锁的方式保证线程安全。加的锁是信号量：dispatch_semaphore。</p>
<pre><code>#define LOCK(...) dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); \
__VA_ARGS__; \
dispatch_semaphore_signal(_lock);
</code></pre>
<p>dispatch_semaphore并不是可重入的。因此，遇到重入的情况，就会发生死锁问题。举的例子只是其中一个死锁场景。</p>
<p>YY选择使用dispatch_semaphore的原因，可能是判断dispatch_semaphore的执行效率较高。可以参考YY对各种锁的效率测评：https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/</p>
<h3 id="修复方法">修复方法：</h3>
<p>使用pthread_mutex替代dispatch_semaphore。pthread_mutex有参数可以设置为可重入。在YY测试的执行效率上，可重入的pthread_mutex是可重入锁中效率较高的一个。</p>
<h2 id="问题2判等导致死锁">问题2：判等导致死锁</h2>
<p>在使用pthread_mutex替代dispatch_semaphore的方式修复了可重入锁的问题后，我们发现YYThreadSafeArray在判等处的代码是有死锁隐患的。</p>
<h3 id="调用方式-2">调用方式：</h3>
<pre><code>YYThreadSafeArray *threadSafeArrayA = [[YYThreadSafeArray alloc] init];
YYThreadSafeArray *threadSafeArrayB = [[YYThreadSafeArray alloc] init];
for (int i = 0; i &lt; 1000000; i++) {
    [threadSafeArrayA addObject:@(i)];
    [threadSafeArrayB addObject:@(i)];
}
    
for (int i = 0; i &lt; 10000; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        [threadSafeArrayB isEqualToArray:threadSafeArrayA];
    });
    [threadSafeArrayA isEqualToArray:threadSafeArrayB];
}
</code></pre>
<p>如果两个线程中，同时分别执行</p>
<pre><code> [A isEqualToArray:B];
</code></pre>
<p>和</p>
<pre><code> [B isEqualToArray:A];
</code></pre>
<p>则会有一定概率死锁。</p>
<h3 id="原因分析-2">原因分析：</h3>
<p>我们查看YYThreadSafeArray中isEqualToArray方法的源码：</p>
<pre><code>- (BOOL)isEqualToArray:(NSArray *)otherArray {
    if (otherArray == self) return YES;
    if ([otherArray isKindOfClass:YYThreadSafeArray.class]) {
        YYThreadSafeArray *other = (id)otherArray;
        BOOL isEqual;
        dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER);
        dispatch_semaphore_wait(other-&gt;_lock, DISPATCH_TIME_FOREVER);
        isEqual = [_arr isEqualToArray:other-&gt;_arr];
        dispatch_semaphore_signal(other-&gt;_lock);
        dispatch_semaphore_signal(_lock);
        return isEqual;
    }
    return NO;
}
</code></pre>
<p>在线程1中调用</p>
<pre><code> [A isEqualToArray:B];
</code></pre>
<p>此时，执行完</p>
<pre><code>dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER);
</code></pre>
<p>这行，A的_lock锁进入锁住状态。</p>
<p>同时，线程2调用</p>
<pre><code> [B isEqualToArray:A];
</code></pre>
<p>执行完</p>
<pre><code>dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER);
</code></pre>
<p>这行，B的_lock锁也进入锁住状态。</p>
<p>那么线程1在执行下一行</p>
<pre><code>dispatch_semaphore_wait(other-&gt;_lock, DISPATCH_TIME_FOREVER);
</code></pre>
<p>时，由于<code>B -&gt;_lock</code>已经被锁住，线程1不得不阻塞在此，等待B的锁被解锁。<br>
而同时，B也在执行同一行代码时，在等待A的锁被解锁。<br>
这就造成了死锁的情形。</p>
<p>代码类似的<code>isEqual:</code>方法也有一样的问题。</p>
<h3 id="修复方法-2">修复方法：</h3>
<p>为了修复这个场景，我们引入了一个新的全局的锁，将整个方法锁起来，防止两个线程同时进入<code>isEqualToArray:</code>方法中。</p>
<h2 id="问题3for-in循环的线程不安全">问题3：for-in循环的线程不安全</h2>
<p>YYThreadSafeArray在只用for-in循环时，是无法保证线程安全的。</p>
<h3 id="调用方式-3">调用方式：</h3>
<pre><code>YYThreadSafeArray *threadSafeArray = [[YYThreadSafeArray alloc] init];
for (int i = 0; i &lt; 1000000; i++) {
    [threadSafeArray addObject:@(i)];
}
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    for (int i = 0; i &lt; 100000; i++) {
        [threadSafeArray removeLastObject];
    }
});
for (id obj in threadSafeArray) {
    (void)obj;
}
</code></pre>
<p>此时大概率会抛出异常：</p>
<pre><code>*** Terminating app due to uncaught exception 'NSGenericException', reason: '*** Collection &lt;YYThreadSafeArray: 0x60000165aa20&gt; was mutated while being enumerated.'
</code></pre>
<h3 id="原因分析-3">原因分析：</h3>
<p>在执行for-in循环时，会调用NSArray的</p>
<pre><code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state
                                  objects:(id __unsafe_unretained[])stackbuf
                                    count:(NSUInteger)len;
</code></pre>
<p>方法。</p>
<p>for-in循环之所以有更高的效率，是因为在循环时，它并非每次都访问NSArray数组，而是直接将一段NSArray数组，当作一个C数组来访问，直接便利这个C数组。对于NSArray来说，<code>state.itemsPtr</code>字段将返回这个C数组的指针。</p>
<p>但在这个方法中加锁，锁住的只是寻找这个C数组的过程，并不能锁住整个for-in循环过程。所以，当多线程进入时，会抛出<code>was mutated while being enumerated</code>异常。</p>
<h3 id="修复方法-3">修复方法：</h3>
<p>这个问题没有想到优雅的修复方法。有2种不怎么优雅的方式可选：</p>
<ol>
<li>让调用方用enumerateObjectsUsingBlock这种遍历方法替代for-in循环，但在效率上肯定有折损；</li>
<li>将YYThreadSafeArray种的锁暴露出去，让业务方在for-in循环时自行加锁。</li>
</ol>
<p>但这两种方法都依赖于调用方以一个特定的姿势来调用。如果调用姿势无法保证，YYThreadSafeArray也无法保证线程安全了。</p>
]]></content>
    </entry>
</feed>